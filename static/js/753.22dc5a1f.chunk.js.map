{"version":3,"file":"static/js/753.22dc5a1f.chunk.js","mappings":"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","sources":["../node_modules/fast-deep-equal/index.js","../node_modules/react-dnd/src/core/DndContext.ts","../node_modules/@react-dnd/invariant/src/index.ts","../node_modules/dnd-core/src/utils/js_utils.ts","../node_modules/dnd-core/src/actions/dragDrop/types.ts","../node_modules/dnd-core/src/actions/dragDrop/local/setClientOffset.ts","../node_modules/dnd-core/src/actions/dragDrop/beginDrag.ts","../node_modules/dnd-core/src/actions/dragDrop/drop.ts","../node_modules/dnd-core/src/actions/dragDrop/endDrag.ts","../node_modules/dnd-core/src/utils/matchesType.ts","../node_modules/dnd-core/src/actions/dragDrop/hover.ts","../node_modules/dnd-core/src/actions/dragDrop/publishDragSource.ts","../node_modules/dnd-core/src/classes/DragDropManagerImpl.ts","../node_modules/dnd-core/src/actions/dragDrop/index.ts","../node_modules/dnd-core/src/utils/coords.ts","../node_modules/dnd-core/src/utils/dirtiness.ts","../node_modules/dnd-core/src/classes/DragDropMonitorImpl.ts","../node_modules/@react-dnd/asap/src/makeRequestCall.ts","../node_modules/@react-dnd/asap/src/AsapQueue.ts","../node_modules/@react-dnd/asap/src/RawTask.ts","../node_modules/@react-dnd/asap/src/TaskFactory.ts","../node_modules/@react-dnd/asap/src/asap.ts","../node_modules/dnd-core/src/actions/registry.ts","../node_modules/dnd-core/src/interfaces.ts","../node_modules/dnd-core/src/contracts.ts","../node_modules/dnd-core/src/utils/getNextUniqueId.ts","../node_modules/dnd-core/src/classes/HandlerRegistryImpl.ts","../node_modules/dnd-core/src/utils/equality.ts","../node_modules/dnd-core/src/reducers/dirtyHandlerIds.ts","../node_modules/dnd-core/src/reducers/dragOffset.ts","../node_modules/dnd-core/src/reducers/dragOperation.ts","../node_modules/dnd-core/src/reducers/refCount.ts","../node_modules/dnd-core/src/reducers/stateId.ts","../node_modules/dnd-core/src/reducers/index.ts","../node_modules/dnd-core/src/createDragDropManager.ts","../node_modules/react-dnd/src/core/DndProvider.tsx","../node_modules/react-dnd/src/core/DragPreviewImage.ts","../node_modules/react-dnd/src/hooks/useIsomorphicLayoutEffect.ts","../node_modules/react-dnd/src/hooks/useCollector.ts","../node_modules/react-dnd/src/hooks/useCollectedProps.ts","../node_modules/react-dnd/src/hooks/useMonitorOutput.ts","../node_modules/react-dnd/src/hooks/useOptionalFactory.ts","../node_modules/react-dnd/src/hooks/useDrag/connectors.ts","../node_modules/@react-dnd/shallowequal/src/index.ts","../node_modules/react-dnd/src/internals/isRef.ts","../node_modules/react-dnd/src/internals/wrapConnectorHooks.ts","../node_modules/react-dnd/src/internals/SourceConnector.ts","../node_modules/react-dnd/src/hooks/useDragDropManager.ts","../node_modules/react-dnd/src/internals/DragSourceMonitorImpl.ts","../node_modules/react-dnd/src/hooks/useDrag/DragSourceImpl.ts","../node_modules/react-dnd/src/hooks/useDrag/useRegisteredDragSource.ts","../node_modules/react-dnd/src/hooks/useDrag/useDragSource.ts","../node_modules/react-dnd/src/hooks/useDrag/useDragType.ts","../node_modules/react-dnd/src/internals/registration.ts","../node_modules/react-dnd/src/hooks/useDrag/useDrag.ts","../node_modules/react-dnd/src/hooks/useDrag/useDragSourceMonitor.ts","../node_modules/react-dnd/src/hooks/useDrag/useDragSourceConnector.ts","../node_modules/react-dnd/src/hooks/useDragLayer.ts","../node_modules/react-dnd/src/hooks/useDrop/connectors.ts","../node_modules/react-dnd/src/internals/TargetConnector.ts","../node_modules/react-dnd/src/internals/DropTargetMonitorImpl.ts","../node_modules/react-dnd/src/hooks/useDrop/DropTargetImpl.ts","../node_modules/react-dnd/src/hooks/useDrop/useRegisteredDropTarget.ts","../node_modules/react-dnd/src/hooks/useDrop/useDropTarget.ts","../node_modules/react-dnd/src/hooks/useDrop/useAccept.ts","../node_modules/react-dnd/src/hooks/useDrop/useDrop.ts","../node_modules/react-dnd/src/hooks/useDrop/useDropTargetMonitor.ts","../node_modules/react-dnd/src/hooks/useDrop/useDropTargetConnector.ts"],"sourcesContent":["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","import type { DragDropManager } from 'dnd-core'\nimport { createContext } from 'react'\n\n/**\n * The React context type\n */\nexport interface DndContextType {\n\tdragDropManager: DragDropManager | undefined\n}\n\n/**\n * Create the React Context\n */\nexport const DndContext = createContext<DndContextType>({\n\tdragDropManager: undefined,\n})\n","/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nexport function invariant(condition: any, format: string, ...args: any[]) {\n\tif (isProduction()) {\n\t\tif (format === undefined) {\n\t\t\tthrow new Error('invariant requires an error message argument')\n\t\t}\n\t}\n\n\tif (!condition) {\n\t\tlet error\n\t\tif (format === undefined) {\n\t\t\terror = new Error(\n\t\t\t\t'Minified exception occurred; use the non-minified dev environment ' +\n\t\t\t\t\t'for the full error message and additional helpful warnings.',\n\t\t\t)\n\t\t} else {\n\t\t\tlet argIndex = 0\n\t\t\terror = new Error(\n\t\t\t\tformat.replace(/%s/g, function () {\n\t\t\t\t\treturn args[argIndex++]\n\t\t\t\t}),\n\t\t\t)\n\t\t\terror.name = 'Invariant Violation'\n\t\t}\n\n\t\t;(error as any).framesToPop = 1 // we don't care about invariant's own frame\n\t\tthrow error\n\t}\n}\n\nfunction isProduction() {\n\treturn (\n\t\ttypeof process !== 'undefined' && process.env['NODE_ENV'] === 'production'\n\t)\n}\n","// cheap lodash replacements\n\n/**\n * drop-in replacement for _.get\n * @param obj\n * @param path\n * @param defaultValue\n */\nexport function get<T>(obj: any, path: string, defaultValue: T): T {\n\treturn path\n\t\t.split('.')\n\t\t.reduce((a, c) => (a && a[c] ? a[c] : defaultValue || null), obj) as T\n}\n\n/**\n * drop-in replacement for _.without\n */\nexport function without<T>(items: T[], item: T): T[] {\n\treturn items.filter((i) => i !== item)\n}\n\n/**\n * drop-in replacement for _.isString\n * @param input\n */\nexport function isString(input: any): boolean {\n\treturn typeof input === 'string'\n}\n\n/**\n * drop-in replacement for _.isString\n * @param input\n */\nexport function isObject(input: any): boolean {\n\treturn typeof input === 'object'\n}\n\n/**\n * replacement for _.xor\n * @param itemsA\n * @param itemsB\n */\nexport function xor<T extends string | number>(itemsA: T[], itemsB: T[]): T[] {\n\tconst map = new Map<T, number>()\n\tconst insertItem = (item: T) => {\n\t\tmap.set(item, map.has(item) ? (map.get(item) as number) + 1 : 1)\n\t}\n\titemsA.forEach(insertItem)\n\titemsB.forEach(insertItem)\n\n\tconst result: T[] = []\n\tmap.forEach((count, key) => {\n\t\tif (count === 1) {\n\t\t\tresult.push(key)\n\t\t}\n\t})\n\treturn result\n}\n\n/**\n * replacement for _.intersection\n * @param itemsA\n * @param itemsB\n */\nexport function intersection<T>(itemsA: T[], itemsB: T[]): T[] {\n\treturn itemsA.filter((t) => itemsB.indexOf(t) > -1)\n}\n","export const INIT_COORDS = 'dnd-core/INIT_COORDS'\nexport const BEGIN_DRAG = 'dnd-core/BEGIN_DRAG'\nexport const PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE'\nexport const HOVER = 'dnd-core/HOVER'\nexport const DROP = 'dnd-core/DROP'\nexport const END_DRAG = 'dnd-core/END_DRAG'\n","import type { AnyAction } from 'redux'\n\nimport type { XYCoord } from '../../../interfaces.js'\nimport { INIT_COORDS } from '../types.js'\n\nexport function setClientOffset(\n\tclientOffset: XYCoord | null | undefined,\n\tsourceClientOffset?: XYCoord | null | undefined,\n): AnyAction {\n\treturn {\n\t\ttype: INIT_COORDS,\n\t\tpayload: {\n\t\t\tsourceClientOffset: sourceClientOffset || null,\n\t\t\tclientOffset: clientOffset || null,\n\t\t},\n\t}\n}\n","import { invariant } from '@react-dnd/invariant'\n\nimport type {\n\tAction,\n\tBeginDragOptions,\n\tBeginDragPayload,\n\tDragDropManager,\n\tDragDropMonitor,\n\tHandlerRegistry,\n\tIdentifier,\n\tXYCoord,\n} from '../../interfaces.js'\nimport { isObject } from '../../utils/js_utils.js'\nimport { setClientOffset } from './local/setClientOffset.js'\nimport { BEGIN_DRAG, INIT_COORDS } from './types.js'\n\nconst ResetCoordinatesAction = {\n\ttype: INIT_COORDS,\n\tpayload: {\n\t\tclientOffset: null,\n\t\tsourceClientOffset: null,\n\t},\n}\n\nexport function createBeginDrag(manager: DragDropManager) {\n\treturn function beginDrag(\n\t\tsourceIds: Identifier[] = [],\n\t\toptions: BeginDragOptions = {\n\t\t\tpublishSource: true,\n\t\t},\n\t): Action<BeginDragPayload> | undefined {\n\t\tconst {\n\t\t\tpublishSource = true,\n\t\t\tclientOffset,\n\t\t\tgetSourceClientOffset,\n\t\t}: BeginDragOptions = options\n\t\tconst monitor = manager.getMonitor()\n\t\tconst registry = manager.getRegistry()\n\n\t\t// Initialize the coordinates using the client offset\n\t\tmanager.dispatch(setClientOffset(clientOffset))\n\n\t\tverifyInvariants(sourceIds, monitor, registry)\n\n\t\t// Get the draggable source\n\t\tconst sourceId = getDraggableSource(sourceIds, monitor)\n\t\tif (sourceId == null) {\n\t\t\tmanager.dispatch(ResetCoordinatesAction)\n\t\t\treturn\n\t\t}\n\n\t\t// Get the source client offset\n\t\tlet sourceClientOffset: XYCoord | null = null\n\t\tif (clientOffset) {\n\t\t\tif (!getSourceClientOffset) {\n\t\t\t\tthrow new Error('getSourceClientOffset must be defined')\n\t\t\t}\n\t\t\tverifyGetSourceClientOffsetIsFunction(getSourceClientOffset)\n\t\t\tsourceClientOffset = getSourceClientOffset(sourceId)\n\t\t}\n\n\t\t// Initialize the full coordinates\n\t\tmanager.dispatch(setClientOffset(clientOffset, sourceClientOffset))\n\n\t\tconst source = registry.getSource(sourceId)\n\t\tconst item = source.beginDrag(monitor, sourceId)\n\t\t// If source.beginDrag returns null, this is an indicator to cancel the drag\n\t\tif (item == null) {\n\t\t\treturn undefined\n\t\t}\n\t\tverifyItemIsObject(item)\n\t\tregistry.pinSource(sourceId)\n\n\t\tconst itemType = registry.getSourceType(sourceId)\n\t\treturn {\n\t\t\ttype: BEGIN_DRAG,\n\t\t\tpayload: {\n\t\t\t\titemType,\n\t\t\t\titem,\n\t\t\t\tsourceId,\n\t\t\t\tclientOffset: clientOffset || null,\n\t\t\t\tsourceClientOffset: sourceClientOffset || null,\n\t\t\t\tisSourcePublic: !!publishSource,\n\t\t\t},\n\t\t}\n\t}\n}\n\nfunction verifyInvariants(\n\tsourceIds: Identifier[],\n\tmonitor: DragDropMonitor,\n\tregistry: HandlerRegistry,\n) {\n\tinvariant(!monitor.isDragging(), 'Cannot call beginDrag while dragging.')\n\tsourceIds.forEach(function (sourceId) {\n\t\tinvariant(\n\t\t\tregistry.getSource(sourceId),\n\t\t\t'Expected sourceIds to be registered.',\n\t\t)\n\t})\n}\n\nfunction verifyGetSourceClientOffsetIsFunction(getSourceClientOffset: any) {\n\tinvariant(\n\t\ttypeof getSourceClientOffset === 'function',\n\t\t'When clientOffset is provided, getSourceClientOffset must be a function.',\n\t)\n}\n\nfunction verifyItemIsObject(item: any) {\n\tinvariant(isObject(item), 'Item must be an object.')\n}\n\nfunction getDraggableSource(sourceIds: Identifier[], monitor: DragDropMonitor) {\n\tlet sourceId = null\n\tfor (let i = sourceIds.length - 1; i >= 0; i--) {\n\t\tif (monitor.canDragSource(sourceIds[i])) {\n\t\t\tsourceId = sourceIds[i]\n\t\t\tbreak\n\t\t}\n\t}\n\treturn sourceId\n}\n","import { invariant } from '@react-dnd/invariant'\n\nimport type {\n\tAction,\n\tDragDropManager,\n\tDragDropMonitor,\n\tDropPayload,\n\tHandlerRegistry,\n\tIdentifier,\n} from '../../interfaces.js'\nimport { isObject } from '../../utils/js_utils.js'\nimport { DROP } from './types.js'\n\nexport function createDrop(manager: DragDropManager) {\n\treturn function drop(options = {}): void {\n\t\tconst monitor = manager.getMonitor()\n\t\tconst registry = manager.getRegistry()\n\t\tverifyInvariants(monitor)\n\t\tconst targetIds = getDroppableTargets(monitor)\n\n\t\t// Multiple actions are dispatched here, which is why this doesn't return an action\n\t\ttargetIds.forEach((targetId, index) => {\n\t\t\tconst dropResult = determineDropResult(targetId, index, registry, monitor)\n\t\t\tconst action: Action<DropPayload> = {\n\t\t\t\ttype: DROP,\n\t\t\t\tpayload: {\n\t\t\t\t\tdropResult: {\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\t...dropResult,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tmanager.dispatch(action)\n\t\t})\n\t}\n}\n\nfunction verifyInvariants(monitor: DragDropMonitor) {\n\tinvariant(monitor.isDragging(), 'Cannot call drop while not dragging.')\n\tinvariant(\n\t\t!monitor.didDrop(),\n\t\t'Cannot call drop twice during one drag operation.',\n\t)\n}\n\nfunction determineDropResult(\n\ttargetId: Identifier,\n\tindex: number,\n\tregistry: HandlerRegistry,\n\tmonitor: DragDropMonitor,\n) {\n\tconst target = registry.getTarget(targetId)\n\tlet dropResult = target ? target.drop(monitor, targetId) : undefined\n\tverifyDropResultType(dropResult)\n\tif (typeof dropResult === 'undefined') {\n\t\tdropResult = index === 0 ? {} : monitor.getDropResult()\n\t}\n\treturn dropResult\n}\n\nfunction verifyDropResultType(dropResult: any) {\n\tinvariant(\n\t\ttypeof dropResult === 'undefined' || isObject(dropResult),\n\t\t'Drop result must either be an object or undefined.',\n\t)\n}\n\nfunction getDroppableTargets(monitor: DragDropMonitor) {\n\tconst targetIds = monitor\n\t\t.getTargetIds()\n\t\t.filter(monitor.canDropOnTarget, monitor)\n\ttargetIds.reverse()\n\treturn targetIds\n}\n","import { invariant } from '@react-dnd/invariant'\n\nimport type {\n\tDragDropManager,\n\tDragDropMonitor,\n\tSentinelAction,\n} from '../../interfaces.js'\nimport { END_DRAG } from './types.js'\n\nexport function createEndDrag(manager: DragDropManager) {\n\treturn function endDrag(): SentinelAction {\n\t\tconst monitor = manager.getMonitor()\n\t\tconst registry = manager.getRegistry()\n\t\tverifyIsDragging(monitor)\n\n\t\tconst sourceId = monitor.getSourceId()\n\t\tif (sourceId != null) {\n\t\t\tconst source = registry.getSource(sourceId, true)\n\t\t\tsource.endDrag(monitor, sourceId)\n\t\t\tregistry.unpinSource()\n\t\t}\n\t\treturn { type: END_DRAG }\n\t}\n}\n\nfunction verifyIsDragging(monitor: DragDropMonitor) {\n\tinvariant(monitor.isDragging(), 'Cannot call endDrag while not dragging.')\n}\n","import type { Identifier } from '../interfaces.js'\n\nexport function matchesType(\n\ttargetType: Identifier | Identifier[] | null,\n\tdraggedItemType: Identifier | null,\n): boolean {\n\tif (draggedItemType === null) {\n\t\treturn targetType === null\n\t}\n\treturn Array.isArray(targetType)\n\t\t? (targetType as Identifier[]).some((t) => t === draggedItemType)\n\t\t: targetType === draggedItemType\n}\n","import { invariant } from '@react-dnd/invariant'\n\nimport type {\n\tAction,\n\tDragDropManager,\n\tDragDropMonitor,\n\tHandlerRegistry,\n\tHoverOptions,\n\tHoverPayload,\n\tIdentifier,\n} from '../../interfaces.js'\nimport { matchesType } from '../../utils/matchesType.js'\nimport { HOVER } from './types.js'\n\nexport function createHover(manager: DragDropManager) {\n\treturn function hover(\n\t\ttargetIdsArg: string[],\n\t\t{ clientOffset }: HoverOptions = {},\n\t): Action<HoverPayload> {\n\t\tverifyTargetIdsIsArray(targetIdsArg)\n\t\tconst targetIds = targetIdsArg.slice(0)\n\t\tconst monitor = manager.getMonitor()\n\t\tconst registry = manager.getRegistry()\n\t\tconst draggedItemType = monitor.getItemType()\n\t\tremoveNonMatchingTargetIds(targetIds, registry, draggedItemType)\n\t\tcheckInvariants(targetIds, monitor, registry)\n\t\thoverAllTargets(targetIds, monitor, registry)\n\n\t\treturn {\n\t\t\ttype: HOVER,\n\t\t\tpayload: {\n\t\t\t\ttargetIds,\n\t\t\t\tclientOffset: clientOffset || null,\n\t\t\t},\n\t\t}\n\t}\n}\n\nfunction verifyTargetIdsIsArray(targetIdsArg: string[]) {\n\tinvariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.')\n}\n\nfunction checkInvariants(\n\ttargetIds: string[],\n\tmonitor: DragDropMonitor,\n\tregistry: HandlerRegistry,\n) {\n\tinvariant(monitor.isDragging(), 'Cannot call hover while not dragging.')\n\tinvariant(!monitor.didDrop(), 'Cannot call hover after drop.')\n\tfor (let i = 0; i < targetIds.length; i++) {\n\t\tconst targetId = targetIds[i] as string\n\t\tinvariant(\n\t\t\ttargetIds.lastIndexOf(targetId) === i,\n\t\t\t'Expected targetIds to be unique in the passed array.',\n\t\t)\n\n\t\tconst target = registry.getTarget(targetId)\n\t\tinvariant(target, 'Expected targetIds to be registered.')\n\t}\n}\n\nfunction removeNonMatchingTargetIds(\n\ttargetIds: string[],\n\tregistry: HandlerRegistry,\n\tdraggedItemType: Identifier | null,\n) {\n\t// Remove those targetIds that don't match the targetType.  This\n\t// fixes shallow isOver which would only be non-shallow because of\n\t// non-matching targets.\n\tfor (let i = targetIds.length - 1; i >= 0; i--) {\n\t\tconst targetId = targetIds[i] as string\n\t\tconst targetType = registry.getTargetType(targetId)\n\t\tif (!matchesType(targetType, draggedItemType)) {\n\t\t\ttargetIds.splice(i, 1)\n\t\t}\n\t}\n}\n\nfunction hoverAllTargets(\n\ttargetIds: string[],\n\tmonitor: DragDropMonitor,\n\tregistry: HandlerRegistry,\n) {\n\t// Finally call hover on all matching targets.\n\ttargetIds.forEach(function (targetId) {\n\t\tconst target = registry.getTarget(targetId)\n\t\ttarget.hover(monitor, targetId)\n\t})\n}\n","import type { DragDropManager, SentinelAction } from '../../interfaces.js'\nimport { PUBLISH_DRAG_SOURCE } from './types.js'\n\nexport function createPublishDragSource(manager: DragDropManager) {\n\treturn function publishDragSource(): SentinelAction | undefined {\n\t\tconst monitor = manager.getMonitor()\n\t\tif (monitor.isDragging()) {\n\t\t\treturn { type: PUBLISH_DRAG_SOURCE }\n\t\t}\n\t\treturn\n\t}\n}\n","import type { Action, Store } from 'redux'\n\nimport { createDragDropActions } from '../actions/dragDrop/index.js'\nimport type {\n\tActionCreator,\n\tBackend,\n\tDragDropActions,\n\tDragDropManager,\n\tDragDropMonitor,\n\tHandlerRegistry,\n} from '../interfaces.js'\nimport type { State } from '../reducers/index.js'\nimport type { DragDropMonitorImpl } from './DragDropMonitorImpl.js'\n\nexport class DragDropManagerImpl implements DragDropManager {\n\tprivate store: Store<State>\n\tprivate monitor: DragDropMonitor\n\tprivate backend: Backend | undefined\n\tprivate isSetUp = false\n\n\tpublic constructor(store: Store<State>, monitor: DragDropMonitor) {\n\t\tthis.store = store\n\t\tthis.monitor = monitor\n\t\tstore.subscribe(this.handleRefCountChange)\n\t}\n\n\tpublic receiveBackend(backend: Backend): void {\n\t\tthis.backend = backend\n\t}\n\n\tpublic getMonitor(): DragDropMonitor {\n\t\treturn this.monitor\n\t}\n\n\tpublic getBackend(): Backend {\n\t\treturn this.backend as Backend\n\t}\n\n\tpublic getRegistry(): HandlerRegistry {\n\t\treturn (this.monitor as DragDropMonitorImpl).registry\n\t}\n\n\tpublic getActions(): DragDropActions {\n\t\t/* eslint-disable-next-line @typescript-eslint/no-this-alias */\n\t\tconst manager = this\n\t\tconst { dispatch } = this.store\n\n\t\tfunction bindActionCreator(actionCreator: ActionCreator<any>) {\n\t\t\treturn (...args: any[]) => {\n\t\t\t\tconst action = actionCreator.apply(manager, args as any)\n\t\t\t\tif (typeof action !== 'undefined') {\n\t\t\t\t\tdispatch(action)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst actions = createDragDropActions(this)\n\n\t\treturn Object.keys(actions).reduce(\n\t\t\t(boundActions: DragDropActions, key: string) => {\n\t\t\t\tconst action: ActionCreator<any> = (actions as any)[\n\t\t\t\t\tkey\n\t\t\t\t] as ActionCreator<any>\n\t\t\t\t;(boundActions as any)[key] = bindActionCreator(action)\n\t\t\t\treturn boundActions\n\t\t\t},\n\t\t\t{} as DragDropActions,\n\t\t)\n\t}\n\n\tpublic dispatch(action: Action<any>): void {\n\t\tthis.store.dispatch(action)\n\t}\n\n\tprivate handleRefCountChange = (): void => {\n\t\tconst shouldSetUp = this.store.getState().refCount > 0\n\t\tif (this.backend) {\n\t\t\tif (shouldSetUp && !this.isSetUp) {\n\t\t\t\tthis.backend.setup()\n\t\t\t\tthis.isSetUp = true\n\t\t\t} else if (!shouldSetUp && this.isSetUp) {\n\t\t\t\tthis.backend.teardown()\n\t\t\t\tthis.isSetUp = false\n\t\t\t}\n\t\t}\n\t}\n}\n","import type { DragDropActions, DragDropManager } from '../../interfaces.js'\nimport { createBeginDrag } from './beginDrag.js'\nimport { createDrop } from './drop.js'\nimport { createEndDrag } from './endDrag.js'\nimport { createHover } from './hover.js'\nimport { createPublishDragSource } from './publishDragSource.js'\n\nexport * from './types.js'\n\nexport function createDragDropActions(\n\tmanager: DragDropManager,\n): DragDropActions {\n\treturn {\n\t\tbeginDrag: createBeginDrag(manager),\n\t\tpublishDragSource: createPublishDragSource(manager),\n\t\thover: createHover(manager),\n\t\tdrop: createDrop(manager),\n\t\tendDrag: createEndDrag(manager),\n\t}\n}\n","import type { XYCoord } from '../interfaces.js'\nimport type { State } from '../reducers/dragOffset.js'\n\n/**\n * Coordinate addition\n * @param a The first coordinate\n * @param b The second coordinate\n */\nexport function add(a: XYCoord, b: XYCoord): XYCoord {\n\treturn {\n\t\tx: a.x + b.x,\n\t\ty: a.y + b.y,\n\t}\n}\n\n/**\n * Coordinate subtraction\n * @param a The first coordinate\n * @param b The second coordinate\n */\nexport function subtract(a: XYCoord, b: XYCoord): XYCoord {\n\treturn {\n\t\tx: a.x - b.x,\n\t\ty: a.y - b.y,\n\t}\n}\n\n/**\n * Returns the cartesian distance of the drag source component's position, based on its position\n * at the time when the current drag operation has started, and the movement difference.\n *\n * Returns null if no item is being dragged.\n *\n * @param state The offset state to compute from\n */\nexport function getSourceClientOffset(state: State): XYCoord | null {\n\tconst { clientOffset, initialClientOffset, initialSourceClientOffset } = state\n\tif (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {\n\t\treturn null\n\t}\n\treturn subtract(\n\t\tadd(clientOffset, initialSourceClientOffset),\n\t\tinitialClientOffset,\n\t)\n}\n\n/**\n * Determines the x,y offset between the client offset and the initial client offset\n *\n * @param state The offset state to compute from\n */\nexport function getDifferenceFromInitialOffset(state: State): XYCoord | null {\n\tconst { clientOffset, initialClientOffset } = state\n\tif (!clientOffset || !initialClientOffset) {\n\t\treturn null\n\t}\n\treturn subtract(clientOffset, initialClientOffset)\n}\n","import { intersection } from './js_utils.js'\n\nexport const NONE: string[] = []\nexport const ALL: string[] = []\n// Add these flags for debug\n;(NONE as any).__IS_NONE__ = true\n;(ALL as any).__IS_ALL__ = true\n\n/**\n * Determines if the given handler IDs are dirty or not.\n *\n * @param dirtyIds The set of dirty handler ids\n * @param handlerIds The set of handler ids to check\n */\nexport function areDirty(\n\tdirtyIds: string[],\n\thandlerIds: string[] | undefined,\n): boolean {\n\tif (dirtyIds === NONE) {\n\t\treturn false\n\t}\n\n\tif (dirtyIds === ALL || typeof handlerIds === 'undefined') {\n\t\treturn true\n\t}\n\n\tconst commonIds = intersection(handlerIds, dirtyIds)\n\treturn commonIds.length > 0\n}\n","import { invariant } from '@react-dnd/invariant'\nimport type { Store } from 'redux'\n\nimport type {\n\tDragDropMonitor,\n\tHandlerRegistry,\n\tIdentifier,\n\tListener,\n\tUnsubscribe,\n\tXYCoord,\n} from '../interfaces.js'\nimport type { State } from '../reducers/index.js'\nimport {\n\tgetDifferenceFromInitialOffset,\n\tgetSourceClientOffset,\n} from '../utils/coords.js'\nimport { areDirty } from '../utils/dirtiness.js'\nimport { matchesType } from '../utils/matchesType.js'\n\nexport class DragDropMonitorImpl implements DragDropMonitor {\n\tprivate store: Store<State>\n\tpublic readonly registry: HandlerRegistry\n\n\tpublic constructor(store: Store<State>, registry: HandlerRegistry) {\n\t\tthis.store = store\n\t\tthis.registry = registry\n\t}\n\n\tpublic subscribeToStateChange(\n\t\tlistener: Listener,\n\t\toptions: { handlerIds?: string[] } = {},\n\t): Unsubscribe {\n\t\tconst { handlerIds } = options\n\t\tinvariant(typeof listener === 'function', 'listener must be a function.')\n\t\tinvariant(\n\t\t\ttypeof handlerIds === 'undefined' || Array.isArray(handlerIds),\n\t\t\t'handlerIds, when specified, must be an array of strings.',\n\t\t)\n\n\t\tlet prevStateId = this.store.getState().stateId\n\t\tconst handleChange = () => {\n\t\t\tconst state = this.store.getState()\n\t\t\tconst currentStateId = state.stateId\n\t\t\ttry {\n\t\t\t\tconst canSkipListener =\n\t\t\t\t\tcurrentStateId === prevStateId ||\n\t\t\t\t\t(currentStateId === prevStateId + 1 &&\n\t\t\t\t\t\t!areDirty(state.dirtyHandlerIds, handlerIds))\n\n\t\t\t\tif (!canSkipListener) {\n\t\t\t\t\tlistener()\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tprevStateId = currentStateId\n\t\t\t}\n\t\t}\n\n\t\treturn this.store.subscribe(handleChange)\n\t}\n\n\tpublic subscribeToOffsetChange(listener: Listener): Unsubscribe {\n\t\tinvariant(typeof listener === 'function', 'listener must be a function.')\n\n\t\tlet previousState = this.store.getState().dragOffset\n\t\tconst handleChange = () => {\n\t\t\tconst nextState = this.store.getState().dragOffset\n\t\t\tif (nextState === previousState) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpreviousState = nextState\n\t\t\tlistener()\n\t\t}\n\n\t\treturn this.store.subscribe(handleChange)\n\t}\n\n\tpublic canDragSource(sourceId: string | undefined): boolean {\n\t\tif (!sourceId) {\n\t\t\treturn false\n\t\t}\n\t\tconst source = this.registry.getSource(sourceId)\n\t\tinvariant(source, `Expected to find a valid source. sourceId=${sourceId}`)\n\n\t\tif (this.isDragging()) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn source.canDrag(this, sourceId)\n\t}\n\n\tpublic canDropOnTarget(targetId: string | undefined): boolean {\n\t\t// undefined on initial render\n\t\tif (!targetId) {\n\t\t\treturn false\n\t\t}\n\t\tconst target = this.registry.getTarget(targetId)\n\t\tinvariant(target, `Expected to find a valid target. targetId=${targetId}`)\n\n\t\tif (!this.isDragging() || this.didDrop()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst targetType = this.registry.getTargetType(targetId)\n\t\tconst draggedItemType = this.getItemType()\n\t\treturn (\n\t\t\tmatchesType(targetType, draggedItemType) && target.canDrop(this, targetId)\n\t\t)\n\t}\n\n\tpublic isDragging(): boolean {\n\t\treturn Boolean(this.getItemType())\n\t}\n\n\tpublic isDraggingSource(sourceId: string | undefined): boolean {\n\t\t// undefined on initial render\n\t\tif (!sourceId) {\n\t\t\treturn false\n\t\t}\n\t\tconst source = this.registry.getSource(sourceId, true)\n\t\tinvariant(source, `Expected to find a valid source. sourceId=${sourceId}`)\n\n\t\tif (!this.isDragging() || !this.isSourcePublic()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst sourceType = this.registry.getSourceType(sourceId)\n\t\tconst draggedItemType = this.getItemType()\n\t\tif (sourceType !== draggedItemType) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn source.isDragging(this, sourceId)\n\t}\n\n\tpublic isOverTarget(\n\t\ttargetId: string | undefined,\n\t\toptions = { shallow: false },\n\t): boolean {\n\t\t// undefined on initial render\n\t\tif (!targetId) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst { shallow } = options\n\t\tif (!this.isDragging()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst targetType = this.registry.getTargetType(targetId)\n\t\tconst draggedItemType = this.getItemType()\n\t\tif (draggedItemType && !matchesType(targetType, draggedItemType)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst targetIds = this.getTargetIds()\n\t\tif (!targetIds.length) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst index = targetIds.indexOf(targetId)\n\t\tif (shallow) {\n\t\t\treturn index === targetIds.length - 1\n\t\t} else {\n\t\t\treturn index > -1\n\t\t}\n\t}\n\n\tpublic getItemType(): Identifier {\n\t\treturn this.store.getState().dragOperation.itemType as Identifier\n\t}\n\n\tpublic getItem(): any {\n\t\treturn this.store.getState().dragOperation.item\n\t}\n\n\tpublic getSourceId(): string | null {\n\t\treturn this.store.getState().dragOperation.sourceId\n\t}\n\n\tpublic getTargetIds(): string[] {\n\t\treturn this.store.getState().dragOperation.targetIds\n\t}\n\n\tpublic getDropResult(): any {\n\t\treturn this.store.getState().dragOperation.dropResult\n\t}\n\n\tpublic didDrop(): boolean {\n\t\treturn this.store.getState().dragOperation.didDrop\n\t}\n\n\tpublic isSourcePublic(): boolean {\n\t\treturn Boolean(this.store.getState().dragOperation.isSourcePublic)\n\t}\n\n\tpublic getInitialClientOffset(): XYCoord | null {\n\t\treturn this.store.getState().dragOffset.initialClientOffset\n\t}\n\n\tpublic getInitialSourceClientOffset(): XYCoord | null {\n\t\treturn this.store.getState().dragOffset.initialSourceClientOffset\n\t}\n\n\tpublic getClientOffset(): XYCoord | null {\n\t\treturn this.store.getState().dragOffset.clientOffset\n\t}\n\n\tpublic getSourceClientOffset(): XYCoord | null {\n\t\treturn getSourceClientOffset(this.store.getState().dragOffset)\n\t}\n\n\tpublic getDifferenceFromInitialOffset(): XYCoord | null {\n\t\treturn getDifferenceFromInitialOffset(this.store.getState().dragOffset)\n\t}\n}\n","// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nconst scope = typeof global !== 'undefined' ? global : self\nconst BrowserMutationObserver =\n\t(scope as any).MutationObserver || (scope as any).WebKitMutationObserver\n\nexport function makeRequestCallFromTimer(callback: () => void) {\n\treturn function requestCall() {\n\t\t// We dispatch a timeout with a specified delay of 0 for engines that\n\t\t// can reliably accommodate that request. This will usually be snapped\n\t\t// to a 4 milisecond delay, but once we're flushing, there's no delay\n\t\t// between events.\n\t\tconst timeoutHandle = setTimeout(handleTimer, 0)\n\t\t// However, since this timer gets frequently dropped in Firefox\n\t\t// workers, we enlist an interval handle that will try to fire\n\t\t// an event 20 times per second until it succeeds.\n\t\tconst intervalHandle = setInterval(handleTimer, 50)\n\n\t\tfunction handleTimer() {\n\t\t\t// Whichever timer succeeds will cancel both timers and\n\t\t\t// execute the callback.\n\t\t\tclearTimeout(timeoutHandle)\n\t\t\tclearInterval(intervalHandle)\n\t\t\tcallback()\n\t\t}\n\t}\n}\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nexport function makeRequestCallFromMutationObserver(callback: () => void) {\n\tlet toggle = 1\n\tconst observer = new BrowserMutationObserver(callback)\n\tconst node = document.createTextNode('')\n\tobserver.observe(node, { characterData: true })\n\treturn function requestCall() {\n\t\ttoggle = -toggle\n\t\t;(node as any).data = toggle\n\t}\n}\n\nexport const makeRequestCall =\n\ttypeof BrowserMutationObserver === 'function'\n\t\t? // MutationObservers are desirable because they have high priority and work\n\t\t  // reliably everywhere they are implemented.\n\t\t  // They are implemented in all modern browsers.\n\t\t  //\n\t\t  // - Android 4-4.3\n\t\t  // - Chrome 26-34\n\t\t  // - Firefox 14-29\n\t\t  // - Internet Explorer 11\n\t\t  // - iPad Safari 6-7.1\n\t\t  // - iPhone Safari 7-7.1\n\t\t  // - Safari 6-7\n\t\t  makeRequestCallFromMutationObserver\n\t\t: // MessageChannels are desirable because they give direct access to the HTML\n\t\t  // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n\t\t  // 11-12, and in web workers in many engines.\n\t\t  // Although message channels yield to any queued rendering and IO tasks, they\n\t\t  // would be better than imposing the 4ms delay of timers.\n\t\t  // However, they do not work reliably in Internet Explorer or Safari.\n\n\t\t  // Internet Explorer 10 is the only browser that has setImmediate but does\n\t\t  // not have MutationObservers.\n\t\t  // Although setImmediate yields to the browser's renderer, it would be\n\t\t  // preferrable to falling back to setTimeout since it does not have\n\t\t  // the minimum 4ms penalty.\n\t\t  // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n\t\t  // Desktop to a lesser extent) that renders both setImmediate and\n\t\t  // MessageChannel useless for the purposes of ASAP.\n\t\t  // https://github.com/kriskowal/q/issues/396\n\n\t\t  // Timers are implemented universally.\n\t\t  // We fall back to timers in workers in most engines, and in foreground\n\t\t  // contexts in the following browsers.\n\t\t  // However, note that even this simple case requires nuances to operate in a\n\t\t  // broad spectrum of browsers.\n\t\t  //\n\t\t  // - Firefox 3-13\n\t\t  // - Internet Explorer 6-9\n\t\t  // - iPad Safari 4.3\n\t\t  // - Lynx 2.8.7\n\t\t  makeRequestCallFromTimer\n","/* eslint-disable no-restricted-globals, @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unused-vars, @typescript-eslint/no-non-null-assertion */\nimport { makeRequestCall, makeRequestCallFromTimer } from './makeRequestCall.js'\nimport type { Task } from './types.js'\n\nexport class AsapQueue {\n\tprivate queue: Task[] = []\n\t// We queue errors to ensure they are thrown in right order (FIFO).\n\t// Array-as-queue is good enough here, since we are just dealing with exceptions.\n\tprivate pendingErrors: any[] = []\n\t// Once a flush has been requested, no further calls to `requestFlush` are\n\t// necessary until the next `flush` completes.\n\t// @ts-ignore\n\tprivate flushing = false\n\t// `requestFlush` is an implementation-specific method that attempts to kick\n\t// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n\t// the event queue before yielding to the browser's own event loop.\n\tprivate requestFlush: () => void\n\n\tprivate requestErrorThrow: () => void\n\t// The position of the next task to execute in the task queue. This is\n\t// preserved between calls to `flush` so that it can be resumed if\n\t// a task throws an exception.\n\tprivate index = 0\n\t// If a task schedules additional tasks recursively, the task queue can grow\n\t// unbounded. To prevent memory exhaustion, the task queue will periodically\n\t// truncate already-completed tasks.\n\tprivate capacity = 1024\n\n\tpublic constructor() {\n\t\t// `requestFlush` requests that the high priority event queue be flushed as\n\t\t// soon as possible.\n\t\t// This is useful to prevent an error thrown in a task from stalling the event\n\t\t// queue if the exception handled by Node.js’s\n\t\t// `process.on(\"uncaughtException\")` or by a domain.\n\n\t\t// `requestFlush` is implemented using a strategy based on data collected from\n\t\t// every available SauceLabs Selenium web driver worker at time of writing.\n\t\t// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\t\tthis.requestFlush = makeRequestCall(this.flush)\n\t\tthis.requestErrorThrow = makeRequestCallFromTimer(() => {\n\t\t\t// Throw first error\n\t\t\tif (this.pendingErrors.length) {\n\t\t\t\tthrow this.pendingErrors.shift()\n\t\t\t}\n\t\t})\n\t}\n\n\t// Use the fastest means possible to execute a task in its own turn, with\n\t// priority over other events including IO, animation, reflow, and redraw\n\t// events in browsers.\n\t//\n\t// An exception thrown by a task will permanently interrupt the processing of\n\t// subsequent tasks. The higher level `asap` function ensures that if an\n\t// exception is thrown by a task, that the task queue will continue flushing as\n\t// soon as possible, but if you use `rawAsap` directly, you are responsible to\n\t// either ensure that no exceptions are thrown from your task, or to manually\n\t// call `rawAsap.requestFlush` if an exception is thrown.\n\tpublic enqueueTask(task: Task): void {\n\t\tconst { queue: q, requestFlush } = this\n\t\tif (!q.length) {\n\t\t\trequestFlush()\n\t\t\tthis.flushing = true\n\t\t}\n\t\t// Equivalent to push, but avoids a function call.\n\t\tq[q.length] = task\n\t}\n\n\t// The flush function processes all tasks that have been scheduled with\n\t// `rawAsap` unless and until one of those tasks throws an exception.\n\t// If a task throws an exception, `flush` ensures that its state will remain\n\t// consistent and will resume where it left off when called again.\n\t// However, `flush` does not make any arrangements to be called again if an\n\t// exception is thrown.\n\tprivate flush = () => {\n\t\tconst { queue: q } = this\n\t\twhile (this.index < q.length) {\n\t\t\tconst currentIndex = this.index\n\t\t\t// Advance the index before calling the task. This ensures that we will\n\t\t\t// begin flushing on the next task the task throws an error.\n\t\t\tthis.index++\n\t\t\tq[currentIndex]!.call()\n\t\t\t// Prevent leaking memory for long chains of recursive calls to `asap`.\n\t\t\t// If we call `asap` within tasks scheduled by `asap`, the queue will\n\t\t\t// grow, but to avoid an O(n) walk for every task we execute, we don't\n\t\t\t// shift tasks off the queue after they have been executed.\n\t\t\t// Instead, we periodically shift 1024 tasks off the queue.\n\t\t\tif (this.index > this.capacity) {\n\t\t\t\t// Manually shift all values starting at the index back to the\n\t\t\t\t// beginning of the queue.\n\t\t\t\tfor (\n\t\t\t\t\tlet scan = 0, newLength = q.length - this.index;\n\t\t\t\t\tscan < newLength;\n\t\t\t\t\tscan++\n\t\t\t\t) {\n\t\t\t\t\tq[scan] = q[scan + this.index]!\n\t\t\t\t}\n\t\t\t\tq.length -= this.index\n\t\t\t\tthis.index = 0\n\t\t\t}\n\t\t}\n\t\tq.length = 0\n\t\tthis.index = 0\n\t\tthis.flushing = false\n\t}\n\n\t// In a web browser, exceptions are not fatal. However, to avoid\n\t// slowing down the queue of pending tasks, we rethrow the error in a\n\t// lower priority turn.\n\tpublic registerPendingError = (err: any) => {\n\t\tthis.pendingErrors.push(err)\n\t\tthis.requestErrorThrow()\n\t}\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// // its existence.\n// rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n","// We wrap tasks with recyclable task objects.  A task object implements\n\nimport type { Task, TaskFn } from 'types'\n\n// `call`, just like a function.\nexport class RawTask implements Task {\n\tpublic task: TaskFn | null = null\n\n\tpublic constructor(\n\t\tprivate onError: (err: any) => void,\n\t\tprivate release: (t: RawTask) => void,\n\t) {}\n\n\tpublic call() {\n\t\ttry {\n\t\t\tthis.task && this.task()\n\t\t} catch (error) {\n\t\t\tthis.onError(error)\n\t\t} finally {\n\t\t\tthis.task = null\n\t\t\tthis.release(this)\n\t\t}\n\t}\n}\n","import { RawTask } from './RawTask.js'\nimport type { Task } from './types.js'\n\nexport class TaskFactory {\n\tprivate freeTasks: RawTask[] = []\n\n\tpublic constructor(private onError: (err: any) => void) {}\n\n\tpublic create(task: () => void): Task {\n\t\tconst tasks = this.freeTasks\n\t\tconst t = tasks.length\n\t\t\t? (tasks.pop() as RawTask)\n\t\t\t: new RawTask(this.onError, (t) => (tasks[tasks.length] = t))\n\t\tt.task = task\n\t\treturn t\n\t}\n}\n","import { AsapQueue } from './AsapQueue.js'\nimport { TaskFactory } from './TaskFactory.js'\nimport type { TaskFn } from './types.js'\n\nconst asapQueue = new AsapQueue()\nconst taskFactory = new TaskFactory(asapQueue.registerPendingError)\n\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */\nexport function asap(task: TaskFn) {\n\tasapQueue.enqueueTask(taskFactory.create(task))\n}\n","import type { Action, SourceIdPayload, TargetIdPayload } from '../interfaces.js'\n\nexport const ADD_SOURCE = 'dnd-core/ADD_SOURCE'\nexport const ADD_TARGET = 'dnd-core/ADD_TARGET'\nexport const REMOVE_SOURCE = 'dnd-core/REMOVE_SOURCE'\nexport const REMOVE_TARGET = 'dnd-core/REMOVE_TARGET'\n\nexport function addSource(sourceId: string): Action<SourceIdPayload> {\n\treturn {\n\t\ttype: ADD_SOURCE,\n\t\tpayload: {\n\t\t\tsourceId,\n\t\t},\n\t}\n}\n\nexport function addTarget(targetId: string): Action<TargetIdPayload> {\n\treturn {\n\t\ttype: ADD_TARGET,\n\t\tpayload: {\n\t\t\ttargetId,\n\t\t},\n\t}\n}\n\nexport function removeSource(sourceId: string): Action<SourceIdPayload> {\n\treturn {\n\t\ttype: REMOVE_SOURCE,\n\t\tpayload: {\n\t\t\tsourceId,\n\t\t},\n\t}\n}\n\nexport function removeTarget(targetId: string): Action<TargetIdPayload> {\n\treturn {\n\t\ttype: REMOVE_TARGET,\n\t\tpayload: {\n\t\t\ttargetId,\n\t\t},\n\t}\n}\n","export type Identifier = string | symbol\nexport type SourceType = Identifier\nexport type TargetType = Identifier | Identifier[]\nexport type Unsubscribe = () => void\nexport type Listener = () => void\n\nexport interface XYCoord {\n\tx: number\n\ty: number\n}\n\nexport enum HandlerRole {\n\tSOURCE = 'SOURCE',\n\tTARGET = 'TARGET',\n}\n\nexport interface Backend {\n\tsetup(): void\n\tteardown(): void\n\tconnectDragSource(sourceId: any, node?: any, options?: any): Unsubscribe\n\tconnectDragPreview(sourceId: any, node?: any, options?: any): Unsubscribe\n\tconnectDropTarget(targetId: any, node?: any, options?: any): Unsubscribe\n\tprofile(): Record<string, number>\n}\n\nexport interface DragDropMonitor {\n\tsubscribeToStateChange(\n\t\tlistener: Listener,\n\t\toptions?: {\n\t\t\thandlerIds?: Identifier[]\n\t\t},\n\t): Unsubscribe\n\tsubscribeToOffsetChange(listener: Listener): Unsubscribe\n\tcanDragSource(sourceId: Identifier | undefined): boolean\n\tcanDropOnTarget(targetId: Identifier | undefined): boolean\n\n\t/**\n\t * Returns true if a drag operation is in progress, and either the owner initiated the drag, or its isDragging()\n\t * is defined and returns true.\n\t */\n\tisDragging(): boolean\n\tisDraggingSource(sourceId: Identifier | undefined): boolean\n\tisOverTarget(\n\t\ttargetId: Identifier | undefined,\n\t\toptions?: {\n\t\t\tshallow?: boolean\n\t\t},\n\t): boolean\n\n\t/**\n\t * Returns a string or a symbol identifying the type of the current dragged item. Returns null if no item is being dragged.\n\t */\n\tgetItemType(): Identifier | null\n\n\t/**\n\t * Returns a plain object representing the currently dragged item. Every drag source must specify it by returning an object\n\t * from its beginDrag() method. Returns null if no item is being dragged.\n\t */\n\tgetItem(): any\n\tgetSourceId(): Identifier | null\n\tgetTargetIds(): Identifier[]\n\t/**\n\t * Returns a plain object representing the last recorded drop result. The drop targets may optionally specify it by returning an\n\t * object from their drop() methods. When a chain of drop() is dispatched for the nested targets, bottom up, any parent that\n\t * explicitly returns its own result from drop() overrides the child drop result previously set by the child. Returns null if\n\t * called outside endDrag().\n\t */\n\tgetDropResult(): any\n\t/**\n\t * Returns true if some drop target has handled the drop event, false otherwise. Even if a target did not return a drop result,\n\t * didDrop() returns true. Use it inside endDrag() to test whether any drop target has handled the drop. Returns false if called\n\t * outside endDrag().\n\t */\n\tdidDrop(): boolean\n\tisSourcePublic(): boolean | null\n\t/**\n\t * Returns the { x, y } client offset of the pointer at the time when the current drag operation has started.\n\t * Returns null if no item is being dragged.\n\t */\n\tgetInitialClientOffset(): XYCoord | null\n\t/**\n\t * Returns the { x, y } client offset of the drag source component's root DOM node at the time when the current drag\n\t * operation has started. Returns null if no item is being dragged.\n\t */\n\tgetInitialSourceClientOffset(): XYCoord | null\n\n\t/**\n\t * Returns the last recorded { x, y } client offset of the pointer while a drag operation is in progress.\n\t * Returns null if no item is being dragged.\n\t */\n\tgetClientOffset(): XYCoord | null\n\n\t/**\n\t * Returns the projected { x, y } client offset of the drag source component's root DOM node, based on its position at the time\n\t * when the current drag operation has started, and the movement difference. Returns null if no item is being dragged.\n\t */\n\tgetSourceClientOffset(): XYCoord | null\n\n\t/**\n\t * Returns the { x, y } difference between the last recorded client offset of the pointer and the client offset when the current\n\t * drag operation has started. Returns null if no item is being dragged.\n\t */\n\tgetDifferenceFromInitialOffset(): XYCoord | null\n}\n\nexport interface HandlerRegistry {\n\taddSource(type: SourceType, source: DragSource): Identifier\n\taddTarget(type: TargetType, target: DropTarget): Identifier\n\tcontainsHandler(handler: DragSource | DropTarget): boolean\n\tgetSource(sourceId: Identifier, includePinned?: boolean): DragSource\n\tgetSourceType(sourceId: Identifier): SourceType\n\tgetTargetType(targetId: Identifier): TargetType\n\tgetTarget(targetId: Identifier): DropTarget\n\tisSourceId(handlerId: Identifier): boolean\n\tisTargetId(handlerId: Identifier): boolean\n\tremoveSource(sourceId: Identifier): void\n\tremoveTarget(targetId: Identifier): void\n\tpinSource(sourceId: Identifier): void\n\tunpinSource(): void\n}\n\nexport interface Action<Payload> {\n\ttype: Identifier\n\tpayload: Payload\n}\nexport interface SentinelAction {\n\ttype: Identifier\n}\n\nexport type ActionCreator<Payload> = (args: any[]) => Action<Payload>\n\nexport interface BeginDragOptions {\n\tpublishSource?: boolean\n\tclientOffset?: XYCoord\n\tgetSourceClientOffset?: (sourceId: Identifier | undefined) => XYCoord\n}\n\nexport interface InitCoordsPayload {\n\tclientOffset: XYCoord | null\n\tsourceClientOffset: XYCoord | null\n}\n\nexport interface BeginDragPayload {\n\titemType: Identifier\n\titem: any\n\tsourceId: Identifier\n\tclientOffset: XYCoord | null\n\tsourceClientOffset: XYCoord | null\n\tisSourcePublic: boolean\n}\n\nexport interface HoverPayload {\n\ttargetIds: Identifier[]\n\tclientOffset: XYCoord | null\n}\n\nexport interface HoverOptions {\n\tclientOffset?: XYCoord\n}\n\nexport interface DropPayload {\n\tdropResult: any\n}\n\nexport interface TargetIdPayload {\n\ttargetId: Identifier\n}\n\nexport interface SourceIdPayload {\n\tsourceId: Identifier\n}\n\nexport interface DragDropActions {\n\tbeginDrag(\n\t\tsourceIds?: Identifier[],\n\t\toptions?: any,\n\t): Action<BeginDragPayload> | undefined\n\tpublishDragSource(): SentinelAction | undefined\n\thover(targetIds: Identifier[], options?: any): Action<HoverPayload>\n\tdrop(options?: any): void\n\tendDrag(): SentinelAction\n}\n\nexport interface DragDropManager {\n\tgetMonitor(): DragDropMonitor\n\tgetBackend(): Backend\n\tgetRegistry(): HandlerRegistry\n\tgetActions(): DragDropActions\n\tdispatch(action: any): void\n}\n\nexport type BackendFactory = (\n\tmanager: DragDropManager,\n\tglobalContext?: any,\n\tconfiguration?: any,\n) => Backend\n\nexport interface DragSource {\n\tbeginDrag(monitor: DragDropMonitor, targetId: Identifier): void\n\tendDrag(monitor: DragDropMonitor, targetId: Identifier): void\n\tcanDrag(monitor: DragDropMonitor, targetId: Identifier): boolean\n\tisDragging(monitor: DragDropMonitor, targetId: Identifier): boolean\n}\n\nexport interface DropTarget {\n\tcanDrop(monitor: DragDropMonitor, targetId: Identifier): boolean\n\thover(monitor: DragDropMonitor, targetId: Identifier): void\n\tdrop(monitor: DragDropMonitor, targetId: Identifier): any\n}\n","import { invariant } from '@react-dnd/invariant'\n\nimport type { DragSource, DropTarget, Identifier } from './interfaces.js'\n\nexport function validateSourceContract(source: DragSource): void {\n\tinvariant(\n\t\ttypeof source.canDrag === 'function',\n\t\t'Expected canDrag to be a function.',\n\t)\n\tinvariant(\n\t\ttypeof source.beginDrag === 'function',\n\t\t'Expected beginDrag to be a function.',\n\t)\n\tinvariant(\n\t\ttypeof source.endDrag === 'function',\n\t\t'Expected endDrag to be a function.',\n\t)\n}\n\nexport function validateTargetContract(target: DropTarget): void {\n\tinvariant(\n\t\ttypeof target.canDrop === 'function',\n\t\t'Expected canDrop to be a function.',\n\t)\n\tinvariant(\n\t\ttypeof target.hover === 'function',\n\t\t'Expected hover to be a function.',\n\t)\n\tinvariant(\n\t\ttypeof target.drop === 'function',\n\t\t'Expected beginDrag to be a function.',\n\t)\n}\n\nexport function validateType(\n\ttype: Identifier | Identifier[],\n\tallowArray?: boolean,\n): void {\n\tif (allowArray && Array.isArray(type)) {\n\t\ttype.forEach((t) => validateType(t, false))\n\t\treturn\n\t}\n\n\tinvariant(\n\t\ttypeof type === 'string' || typeof type === 'symbol',\n\t\tallowArray\n\t\t\t? 'Type can only be a string, a symbol, or an array of either.'\n\t\t\t: 'Type can only be a string or a symbol.',\n\t)\n}\n","let nextUniqueId = 0\n\nexport function getNextUniqueId(): number {\n\treturn nextUniqueId++\n}\n","import { asap } from '@react-dnd/asap'\nimport { invariant } from '@react-dnd/invariant'\nimport type { Store } from 'redux'\n\nimport {\n\taddSource,\n\taddTarget,\n\tremoveSource,\n\tremoveTarget,\n} from '../actions/registry.js'\nimport {\n\tvalidateSourceContract,\n\tvalidateTargetContract,\n\tvalidateType,\n} from '../contracts.js'\nimport type {\n\tDragSource,\n\tDropTarget,\n\tHandlerRegistry,\n\tIdentifier,\n\tSourceType,\n\tTargetType,\n} from '../interfaces.js'\nimport { HandlerRole } from '../interfaces.js'\nimport type { State } from '../reducers/index.js'\nimport { getNextUniqueId } from '../utils/getNextUniqueId.js'\n\nfunction getNextHandlerId(role: HandlerRole): string {\n\tconst id = getNextUniqueId().toString()\n\tswitch (role) {\n\t\tcase HandlerRole.SOURCE:\n\t\t\treturn `S${id}`\n\t\tcase HandlerRole.TARGET:\n\t\t\treturn `T${id}`\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown Handler Role: ${role}`)\n\t}\n}\n\nfunction parseRoleFromHandlerId(handlerId: string) {\n\tswitch (handlerId[0]) {\n\t\tcase 'S':\n\t\t\treturn HandlerRole.SOURCE\n\t\tcase 'T':\n\t\t\treturn HandlerRole.TARGET\n\t\tdefault:\n\t\t\tthrow new Error(`Cannot parse handler ID: ${handlerId}`)\n\t}\n}\n\nfunction mapContainsValue<T>(map: Map<string, T>, searchValue: T) {\n\tconst entries = map.entries()\n\tlet isDone = false\n\tdo {\n\t\tconst {\n\t\t\tdone,\n\t\t\tvalue: [, value],\n\t\t} = entries.next()\n\t\tif (value === searchValue) {\n\t\t\treturn true\n\t\t}\n\t\tisDone = !!done\n\t} while (!isDone)\n\treturn false\n}\n\nexport class HandlerRegistryImpl implements HandlerRegistry {\n\tprivate types: Map<string, SourceType | TargetType> = new Map()\n\tprivate dragSources: Map<string, DragSource> = new Map()\n\tprivate dropTargets: Map<string, DropTarget> = new Map()\n\tprivate pinnedSourceId: string | null = null\n\tprivate pinnedSource: any = null\n\tprivate store: Store<State>\n\n\tpublic constructor(store: Store<State>) {\n\t\tthis.store = store\n\t}\n\n\tpublic addSource(type: SourceType, source: DragSource): string {\n\t\tvalidateType(type)\n\t\tvalidateSourceContract(source)\n\n\t\tconst sourceId = this.addHandler(HandlerRole.SOURCE, type, source)\n\t\tthis.store.dispatch(addSource(sourceId))\n\t\treturn sourceId\n\t}\n\n\tpublic addTarget(type: TargetType, target: DropTarget): string {\n\t\tvalidateType(type, true)\n\t\tvalidateTargetContract(target)\n\n\t\tconst targetId = this.addHandler(HandlerRole.TARGET, type, target)\n\t\tthis.store.dispatch(addTarget(targetId))\n\t\treturn targetId\n\t}\n\n\tpublic containsHandler(handler: DragSource | DropTarget): boolean {\n\t\treturn (\n\t\t\tmapContainsValue(this.dragSources, handler) ||\n\t\t\tmapContainsValue(this.dropTargets, handler)\n\t\t)\n\t}\n\n\tpublic getSource(sourceId: string, includePinned = false): DragSource {\n\t\tinvariant(this.isSourceId(sourceId), 'Expected a valid source ID.')\n\t\tconst isPinned = includePinned && sourceId === this.pinnedSourceId\n\t\tconst source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId)\n\t\treturn source\n\t}\n\n\tpublic getTarget(targetId: string): DropTarget {\n\t\tinvariant(this.isTargetId(targetId), 'Expected a valid target ID.')\n\t\treturn this.dropTargets.get(targetId) as DropTarget\n\t}\n\n\tpublic getSourceType(sourceId: string): Identifier {\n\t\tinvariant(this.isSourceId(sourceId), 'Expected a valid source ID.')\n\t\treturn this.types.get(sourceId) as Identifier\n\t}\n\n\tpublic getTargetType(targetId: string): Identifier | Identifier[] {\n\t\tinvariant(this.isTargetId(targetId), 'Expected a valid target ID.')\n\t\treturn this.types.get(targetId) as Identifier | Identifier[]\n\t}\n\n\tpublic isSourceId(handlerId: string): boolean {\n\t\tconst role = parseRoleFromHandlerId(handlerId)\n\t\treturn role === HandlerRole.SOURCE\n\t}\n\n\tpublic isTargetId(handlerId: string): boolean {\n\t\tconst role = parseRoleFromHandlerId(handlerId)\n\t\treturn role === HandlerRole.TARGET\n\t}\n\n\tpublic removeSource(sourceId: string): void {\n\t\tinvariant(this.getSource(sourceId), 'Expected an existing source.')\n\t\tthis.store.dispatch(removeSource(sourceId))\n\t\tasap(() => {\n\t\t\tthis.dragSources.delete(sourceId)\n\t\t\tthis.types.delete(sourceId)\n\t\t})\n\t}\n\n\tpublic removeTarget(targetId: string): void {\n\t\tinvariant(this.getTarget(targetId), 'Expected an existing target.')\n\t\tthis.store.dispatch(removeTarget(targetId))\n\t\tthis.dropTargets.delete(targetId)\n\t\tthis.types.delete(targetId)\n\t}\n\n\tpublic pinSource(sourceId: string): void {\n\t\tconst source = this.getSource(sourceId)\n\t\tinvariant(source, 'Expected an existing source.')\n\n\t\tthis.pinnedSourceId = sourceId\n\t\tthis.pinnedSource = source\n\t}\n\n\tpublic unpinSource(): void {\n\t\tinvariant(this.pinnedSource, 'No source is pinned at the time.')\n\n\t\tthis.pinnedSourceId = null\n\t\tthis.pinnedSource = null\n\t}\n\n\tprivate addHandler(\n\t\trole: HandlerRole,\n\t\ttype: SourceType | TargetType,\n\t\thandler: DragSource | DropTarget,\n\t): string {\n\t\tconst id = getNextHandlerId(role)\n\t\tthis.types.set(id, type)\n\t\tif (role === HandlerRole.SOURCE) {\n\t\t\tthis.dragSources.set(id, handler as DragSource)\n\t\t} else if (role === HandlerRole.TARGET) {\n\t\t\tthis.dropTargets.set(id, handler as DropTarget)\n\t\t}\n\t\treturn id\n\t}\n}\n","import type { XYCoord } from '../interfaces.js'\n\nexport type EqualityCheck<T> = (a: T, b: T) => boolean\nexport const strictEquality = <T>(a: T, b: T): boolean => a === b\n\n/**\n * Determine if two cartesian coordinate offsets are equal\n * @param offsetA\n * @param offsetB\n */\nexport function areCoordsEqual(\n\toffsetA: XYCoord | null | undefined,\n\toffsetB: XYCoord | null | undefined,\n): boolean {\n\tif (!offsetA && !offsetB) {\n\t\treturn true\n\t} else if (!offsetA || !offsetB) {\n\t\treturn false\n\t} else {\n\t\treturn offsetA.x === offsetB.x && offsetA.y === offsetB.y\n\t}\n}\n\n/**\n * Determines if two arrays of items are equal\n * @param a The first array of items\n * @param b The second array of items\n */\nexport function areArraysEqual<T>(\n\ta: T[],\n\tb: T[],\n\tisEqual: EqualityCheck<T> = strictEquality,\n): boolean {\n\tif (a.length !== b.length) {\n\t\treturn false\n\t}\n\tfor (let i = 0; i < a.length; ++i) {\n\t\tif (!isEqual(a[i] as T, b[i] as T)) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","import {\n\tBEGIN_DRAG,\n\tDROP,\n\tEND_DRAG,\n\tHOVER,\n\tPUBLISH_DRAG_SOURCE,\n} from '../actions/dragDrop/index.js'\nimport {\n\tADD_SOURCE,\n\tADD_TARGET,\n\tREMOVE_SOURCE,\n\tREMOVE_TARGET,\n} from '../actions/registry.js'\nimport type { Action } from '../interfaces.js'\nimport { ALL, NONE } from '../utils/dirtiness.js'\nimport { areArraysEqual } from '../utils/equality.js'\nimport { xor } from '../utils/js_utils.js'\n\nexport type State = string[]\n\nexport interface DirtyHandlerIdPayload {\n\ttargetIds: string[]\n\tprevTargetIds: string[]\n}\n\nexport function reduce(\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t_state: State = NONE,\n\taction: Action<DirtyHandlerIdPayload>,\n): State {\n\tswitch (action.type) {\n\t\tcase HOVER:\n\t\t\tbreak\n\t\tcase ADD_SOURCE:\n\t\tcase ADD_TARGET:\n\t\tcase REMOVE_TARGET:\n\t\tcase REMOVE_SOURCE:\n\t\t\treturn NONE\n\t\tcase BEGIN_DRAG:\n\t\tcase PUBLISH_DRAG_SOURCE:\n\t\tcase END_DRAG:\n\t\tcase DROP:\n\t\tdefault:\n\t\t\treturn ALL\n\t}\n\n\tconst { targetIds = [], prevTargetIds = [] } = action.payload\n\tconst result = xor(targetIds, prevTargetIds)\n\tconst didChange =\n\t\tresult.length > 0 || !areArraysEqual(targetIds, prevTargetIds)\n\n\tif (!didChange) {\n\t\treturn NONE\n\t}\n\n\t// Check the target ids at the innermost position. If they are valid, add them\n\t// to the result\n\tconst prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1]\n\tconst innermostTargetId = targetIds[targetIds.length - 1]\n\tif (prevInnermostTargetId !== innermostTargetId) {\n\t\tif (prevInnermostTargetId) {\n\t\t\tresult.push(prevInnermostTargetId)\n\t\t}\n\t\tif (innermostTargetId) {\n\t\t\tresult.push(innermostTargetId)\n\t\t}\n\t}\n\n\treturn result\n}\n","import {\n\tBEGIN_DRAG,\n\tDROP,\n\tEND_DRAG,\n\tHOVER,\n\tINIT_COORDS,\n} from '../actions/dragDrop/index.js'\nimport type { Action, XYCoord } from '../interfaces.js'\nimport { areCoordsEqual } from '../utils/equality.js'\n\nexport interface State {\n\tinitialSourceClientOffset: XYCoord | null\n\tinitialClientOffset: XYCoord | null\n\tclientOffset: XYCoord | null\n}\n\nconst initialState: State = {\n\tinitialSourceClientOffset: null,\n\tinitialClientOffset: null,\n\tclientOffset: null,\n}\n\nexport function reduce(\n\tstate: State = initialState,\n\taction: Action<{\n\t\tsourceClientOffset: XYCoord\n\t\tclientOffset: XYCoord\n\t}>,\n): State {\n\tconst { payload } = action\n\tswitch (action.type) {\n\t\tcase INIT_COORDS:\n\t\tcase BEGIN_DRAG:\n\t\t\treturn {\n\t\t\t\tinitialSourceClientOffset: payload.sourceClientOffset,\n\t\t\t\tinitialClientOffset: payload.clientOffset,\n\t\t\t\tclientOffset: payload.clientOffset,\n\t\t\t}\n\t\tcase HOVER:\n\t\t\tif (areCoordsEqual(state.clientOffset, payload.clientOffset)) {\n\t\t\t\treturn state\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tclientOffset: payload.clientOffset,\n\t\t\t}\n\t\tcase END_DRAG:\n\t\tcase DROP:\n\t\t\treturn initialState\n\t\tdefault:\n\t\t\treturn state\n\t}\n}\n","import {\n\tBEGIN_DRAG,\n\tDROP,\n\tEND_DRAG,\n\tHOVER,\n\tPUBLISH_DRAG_SOURCE,\n} from '../actions/dragDrop/index.js'\nimport { REMOVE_TARGET } from '../actions/registry.js'\nimport type { Action, Identifier } from '../interfaces.js'\nimport { without } from '../utils/js_utils.js'\n\nexport interface State {\n\titemType: Identifier | Identifier[] | null\n\titem: any\n\tsourceId: string | null\n\ttargetIds: string[]\n\tdropResult: any\n\tdidDrop: boolean\n\tisSourcePublic: boolean | null\n}\n\nconst initialState: State = {\n\titemType: null,\n\titem: null,\n\tsourceId: null,\n\ttargetIds: [],\n\tdropResult: null,\n\tdidDrop: false,\n\tisSourcePublic: null,\n}\n\nexport function reduce(\n\tstate: State = initialState,\n\taction: Action<{\n\t\titemType: Identifier | Identifier[]\n\t\titem: any\n\t\tsourceId: string\n\t\ttargetId: string\n\t\ttargetIds: string[]\n\t\tisSourcePublic: boolean\n\t\tdropResult: any\n\t}>,\n): State {\n\tconst { payload } = action\n\tswitch (action.type) {\n\t\tcase BEGIN_DRAG:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\titemType: payload.itemType,\n\t\t\t\titem: payload.item,\n\t\t\t\tsourceId: payload.sourceId,\n\t\t\t\tisSourcePublic: payload.isSourcePublic,\n\t\t\t\tdropResult: null,\n\t\t\t\tdidDrop: false,\n\t\t\t}\n\t\tcase PUBLISH_DRAG_SOURCE:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tisSourcePublic: true,\n\t\t\t}\n\t\tcase HOVER:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\ttargetIds: payload.targetIds,\n\t\t\t}\n\t\tcase REMOVE_TARGET:\n\t\t\tif (state.targetIds.indexOf(payload.targetId) === -1) {\n\t\t\t\treturn state\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\ttargetIds: without(state.targetIds, payload.targetId),\n\t\t\t}\n\t\tcase DROP:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tdropResult: payload.dropResult,\n\t\t\t\tdidDrop: true,\n\t\t\t\ttargetIds: [],\n\t\t\t}\n\t\tcase END_DRAG:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\titemType: null,\n\t\t\t\titem: null,\n\t\t\t\tsourceId: null,\n\t\t\t\tdropResult: null,\n\t\t\t\tdidDrop: false,\n\t\t\t\tisSourcePublic: null,\n\t\t\t\ttargetIds: [],\n\t\t\t}\n\t\tdefault:\n\t\t\treturn state\n\t}\n}\n","import {\n\tADD_SOURCE,\n\tADD_TARGET,\n\tREMOVE_SOURCE,\n\tREMOVE_TARGET,\n} from '../actions/registry.js'\nimport type { Action } from '../interfaces.js'\n\nexport type State = number\n\nexport function reduce(state: State = 0, action: Action<any>): State {\n\tswitch (action.type) {\n\t\tcase ADD_SOURCE:\n\t\tcase ADD_TARGET:\n\t\t\treturn state + 1\n\t\tcase REMOVE_SOURCE:\n\t\tcase REMOVE_TARGET:\n\t\t\treturn state - 1\n\t\tdefault:\n\t\t\treturn state\n\t}\n}\n","export type State = number\n\nexport function reduce(state: State = 0): State {\n\treturn state + 1\n}\n","import type { Action } from '../interfaces.js'\nimport { get } from '../utils/js_utils.js'\nimport type { State as DirtyHandlerIdsState } from './dirtyHandlerIds.js'\nimport { reduce as dirtyHandlerIds } from './dirtyHandlerIds.js'\nimport type { State as DragOffsetState } from './dragOffset.js'\nimport { reduce as dragOffset } from './dragOffset.js'\nimport type { State as DragOperationState } from './dragOperation.js'\nimport { reduce as dragOperation } from './dragOperation.js'\nimport type { State as RefCountState } from './refCount.js'\nimport { reduce as refCount } from './refCount.js'\nimport type { State as StateIdState } from './stateId.js'\nimport { reduce as stateId } from './stateId.js'\n\nexport interface State {\n\tdirtyHandlerIds: DirtyHandlerIdsState\n\tdragOffset: DragOffsetState\n\trefCount: RefCountState\n\tdragOperation: DragOperationState\n\tstateId: StateIdState\n}\n\nexport function reduce(state: State = {} as State, action: Action<any>): State {\n\treturn {\n\t\tdirtyHandlerIds: dirtyHandlerIds(state.dirtyHandlerIds, {\n\t\t\ttype: action.type,\n\t\t\tpayload: {\n\t\t\t\t...action.payload,\n\t\t\t\tprevTargetIds: get<string[]>(state, 'dragOperation.targetIds', []),\n\t\t\t},\n\t\t}),\n\t\tdragOffset: dragOffset(state.dragOffset, action),\n\t\trefCount: refCount(state.refCount, action),\n\t\tdragOperation: dragOperation(state.dragOperation, action),\n\t\tstateId: stateId(state.stateId),\n\t}\n}\n","import type { Store } from 'redux'\nimport { createStore } from 'redux'\n\nimport { DragDropManagerImpl } from './classes/DragDropManagerImpl.js'\nimport { DragDropMonitorImpl } from './classes/DragDropMonitorImpl.js'\nimport { HandlerRegistryImpl } from './classes/HandlerRegistryImpl.js'\nimport type { BackendFactory, DragDropManager } from './interfaces.js'\nimport type { State } from './reducers/index.js'\nimport { reduce } from './reducers/index.js'\n\nexport function createDragDropManager(\n\tbackendFactory: BackendFactory,\n\tglobalContext: unknown = undefined,\n\tbackendOptions: unknown = {},\n\tdebugMode = false,\n): DragDropManager {\n\tconst store = makeStoreInstance(debugMode)\n\tconst monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store))\n\tconst manager = new DragDropManagerImpl(store, monitor)\n\tconst backend = backendFactory(manager, globalContext, backendOptions)\n\tmanager.receiveBackend(backend)\n\treturn manager\n}\n\nfunction makeStoreInstance(debugMode: boolean): Store<State> {\n\t// TODO: if we ever make a react-native version of this,\n\t// we'll need to consider how to pull off dev-tooling\n\tconst reduxDevTools =\n\t\ttypeof window !== 'undefined' &&\n\t\t(window as any).__REDUX_DEVTOOLS_EXTENSION__\n\treturn createStore(\n\t\treduce,\n\t\tdebugMode &&\n\t\t\treduxDevTools &&\n\t\t\treduxDevTools({\n\t\t\t\tname: 'dnd-core',\n\t\t\t\tinstanceId: 'dnd-core',\n\t\t\t}),\n\t)\n}\n","import type { BackendFactory, DragDropManager } from 'dnd-core'\nimport { createDragDropManager } from 'dnd-core'\nimport type { FC, ReactNode } from 'react'\nimport { memo, useEffect } from 'react'\n\nimport { DndContext } from './DndContext.js'\n\nexport type DndProviderProps<BackendContext, BackendOptions> =\n\t| {\n\t\t\tchildren?: ReactNode\n\t\t\tmanager: DragDropManager\n\t  }\n\t| {\n\t\t\tbackend: BackendFactory\n\t\t\tchildren?: ReactNode\n\t\t\tcontext?: BackendContext\n\t\t\toptions?: BackendOptions\n\t\t\tdebugMode?: boolean\n\t  }\n\nlet refCount = 0\nconst INSTANCE_SYM = Symbol.for('__REACT_DND_CONTEXT_INSTANCE__')\n\n/**\n * A React component that provides the React-DnD context\n */\nexport const DndProvider: FC<DndProviderProps<unknown, unknown>> = memo(\n\tfunction DndProvider({ children, ...props }) {\n\t\tconst [manager, isGlobalInstance] = getDndContextValue(props) // memoized from props\n\t\t/**\n\t\t * If the global context was used to store the DND context\n\t\t * then where theres no more references to it we should\n\t\t * clean it up to avoid memory leaks\n\t\t */\n\t\tuseEffect(() => {\n\t\t\tif (isGlobalInstance) {\n\t\t\t\tconst context = getGlobalContext()\n\t\t\t\t++refCount\n\n\t\t\t\treturn () => {\n\t\t\t\t\tif (--refCount === 0) {\n\t\t\t\t\t\tcontext[INSTANCE_SYM] = null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}, [])\n\n\t\treturn <DndContext.Provider value={manager}>{children}</DndContext.Provider>\n\t},\n)\n\nfunction getDndContextValue(props: DndProviderProps<unknown, unknown>) {\n\tif ('manager' in props) {\n\t\tconst manager = { dragDropManager: props.manager }\n\t\treturn [manager, false]\n\t}\n\n\tconst manager = createSingletonDndContext(\n\t\tprops.backend,\n\t\tprops.context,\n\t\tprops.options,\n\t\tprops.debugMode,\n\t)\n\tconst isGlobalInstance = !props.context\n\n\treturn [manager, isGlobalInstance]\n}\n\nfunction createSingletonDndContext<BackendContext, BackendOptions>(\n\tbackend: BackendFactory,\n\tcontext: BackendContext = getGlobalContext(),\n\toptions: BackendOptions,\n\tdebugMode?: boolean,\n) {\n\tconst ctx = context as any\n\tif (!ctx[INSTANCE_SYM]) {\n\t\tctx[INSTANCE_SYM] = {\n\t\t\tdragDropManager: createDragDropManager(\n\t\t\t\tbackend,\n\t\t\t\tcontext,\n\t\t\t\toptions,\n\t\t\t\tdebugMode,\n\t\t\t),\n\t\t}\n\t}\n\treturn ctx[INSTANCE_SYM]\n}\n\ndeclare const global: any\nfunction getGlobalContext() {\n\treturn typeof global !== 'undefined' ? global : (window as any)\n}\n","import type { FC } from 'react'\nimport { memo, useEffect } from 'react'\n\nimport type { ConnectDragPreview } from '../types/index.js'\n\nexport interface DragPreviewImageProps {\n\tconnect: ConnectDragPreview\n\tsrc: string\n}\n/**\n * A utility for rendering a drag preview image\n */\nexport const DragPreviewImage: FC<DragPreviewImageProps> = memo(\n\tfunction DragPreviewImage({ connect, src }) {\n\t\tuseEffect(() => {\n\t\t\tif (typeof Image === 'undefined') return\n\n\t\t\tlet connected = false\n\t\t\tconst img = new Image()\n\t\t\timg.src = src\n\t\t\timg.onload = () => {\n\t\t\t\tconnect(img)\n\t\t\t\tconnected = true\n\t\t\t}\n\t\t\treturn () => {\n\t\t\t\tif (connected) {\n\t\t\t\t\tconnect(null)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn null\n\t},\n)\n","import { useEffect, useLayoutEffect } from 'react'\n\n// suppress the useLayoutEffect warning on server side.\nexport const useIsomorphicLayoutEffect =\n\ttypeof window !== 'undefined' ? useLayoutEffect : useEffect\n","import equal from 'fast-deep-equal'\nimport { useCallback, useState } from 'react'\n\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect.js'\n\n/**\n *\n * @param monitor The monitor to collect state from\n * @param collect The collecting function\n * @param onUpdate A method to invoke when updates occur\n */\nexport function useCollector<T, S>(\n\tmonitor: T,\n\tcollect: (monitor: T) => S,\n\tonUpdate?: () => void,\n): [S, () => void] {\n\tconst [collected, setCollected] = useState(() => collect(monitor))\n\n\tconst updateCollected = useCallback(() => {\n\t\tconst nextValue = collect(monitor)\n\t\t// This needs to be a deep-equality check because some monitor-collected values\n\t\t// include XYCoord objects that may be equivalent, but do not have instance equality.\n\t\tif (!equal(collected, nextValue)) {\n\t\t\tsetCollected(nextValue)\n\t\t\tif (onUpdate) {\n\t\t\t\tonUpdate()\n\t\t\t}\n\t\t}\n\t}, [collected, monitor, onUpdate])\n\n\t// update the collected properties after react renders.\n\t// Note that the \"Dustbin Stress Test\" fails if this is not\n\t// done when the component updates\n\tuseIsomorphicLayoutEffect(updateCollected)\n\n\treturn [collected, updateCollected]\n}\n","import type { Connector } from '../internals/index.js'\nimport type { HandlerManager, MonitorEventEmitter } from '../types/index.js'\nimport { useMonitorOutput } from './useMonitorOutput.js'\n\nexport function useCollectedProps<Collected, Monitor extends HandlerManager>(\n\tcollector: ((monitor: Monitor) => Collected) | undefined,\n\tmonitor: Monitor & MonitorEventEmitter,\n\tconnector: Connector,\n) {\n\treturn useMonitorOutput(monitor, collector || (() => ({} as Collected)), () =>\n\t\tconnector.reconnect(),\n\t)\n}\n","import type { HandlerManager, MonitorEventEmitter } from '../types/index.js'\nimport { useCollector } from './useCollector.js'\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect.js'\n\nexport function useMonitorOutput<Monitor extends HandlerManager, Collected>(\n\tmonitor: Monitor & MonitorEventEmitter,\n\tcollect: (monitor: Monitor) => Collected,\n\tonCollect?: () => void,\n): Collected {\n\tconst [collected, updateCollected] = useCollector(monitor, collect, onCollect)\n\n\tuseIsomorphicLayoutEffect(\n\t\tfunction subscribeToMonitorStateChange() {\n\t\t\tconst handlerId = monitor.getHandlerId()\n\t\t\tif (handlerId == null) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn monitor.subscribeToStateChange(updateCollected, {\n\t\t\t\thandlerIds: [handlerId],\n\t\t\t})\n\t\t},\n\t\t[monitor, updateCollected],\n\t)\n\n\treturn collected\n}\n","import { useMemo } from 'react'\n\nimport type { FactoryOrInstance } from './types.js'\n\nexport function useOptionalFactory<T>(\n\targ: FactoryOrInstance<T>,\n\tdeps?: unknown[],\n): T {\n\tconst memoDeps = [...(deps || [])]\n\tif (deps == null && typeof arg !== 'function') {\n\t\tmemoDeps.push(arg)\n\t}\n\treturn useMemo<T>(() => {\n\t\treturn typeof arg === 'function' ? (arg as () => T)() : (arg as T)\n\t}, memoDeps)\n}\n","import { useMemo } from 'react'\n\nimport type { SourceConnector } from '../../internals/index.js'\n\nexport function useConnectDragSource(connector: SourceConnector) {\n\treturn useMemo(() => connector.hooks.dragSource(), [connector])\n}\n\nexport function useConnectDragPreview(connector: SourceConnector) {\n\treturn useMemo(() => connector.hooks.dragPreview(), [connector])\n}\n","export function shallowEqual<T>(\n\tobjA: T,\n\tobjB: T,\n\tcompare?: (a: T, b: T, key?: string) => boolean | void,\n\tcompareContext?: any,\n) {\n\tlet compareResult = compare\n\t\t? compare.call(compareContext, objA, objB)\n\t\t: void 0\n\tif (compareResult !== void 0) {\n\t\treturn !!compareResult\n\t}\n\n\tif (objA === objB) {\n\t\treturn true\n\t}\n\n\tif (typeof objA !== 'object' || !objA || typeof objB !== 'object' || !objB) {\n\t\treturn false\n\t}\n\n\tconst keysA = Object.keys(objA)\n\tconst keysB = Object.keys(objB)\n\n\tif (keysA.length !== keysB.length) {\n\t\treturn false\n\t}\n\n\tconst bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB)\n\n\t// Test for A's keys different from B.\n\tfor (let idx = 0; idx < keysA.length; idx++) {\n\t\tconst key = keysA[idx] as string\n\n\t\tif (!bHasOwnProperty(key)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst valueA = (objA as any)[key]\n\t\tconst valueB = (objB as any)[key]\n\n\t\tcompareResult = compare\n\t\t\t? compare.call(compareContext, valueA, valueB, key)\n\t\t\t: void 0\n\n\t\tif (\n\t\t\tcompareResult === false ||\n\t\t\t(compareResult === void 0 && valueA !== valueB)\n\t\t) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n","export interface Ref<T> {\n\tcurrent: T\n}\n\nexport function isRef(obj: unknown): boolean {\n\treturn (\n\t\t// eslint-disable-next-line no-prototype-builtins\n\t\tobj !== null &&\n\t\ttypeof obj === 'object' &&\n\t\tObject.prototype.hasOwnProperty.call(obj, 'current')\n\t)\n}\n","import { invariant } from '@react-dnd/invariant'\nimport type { ReactElement } from 'react'\nimport { cloneElement, isValidElement } from 'react'\n\nfunction throwIfCompositeComponentElement(element: ReactElement<any>) {\n\t// Custom components can no longer be wrapped directly in React DnD 2.0\n\t// so that we don't need to depend on findDOMNode() from react-dom.\n\tif (typeof element.type === 'string') {\n\t\treturn\n\t}\n\n\tconst displayName =\n\t\t(element.type as any).displayName || element.type.name || 'the component'\n\n\tthrow new Error(\n\t\t'Only native element nodes can now be passed to React DnD connectors.' +\n\t\t\t`You can either wrap ${displayName} into a <div>, or turn it into a ` +\n\t\t\t'drag source or a drop target itself.',\n\t)\n}\n\nfunction wrapHookToRecognizeElement(hook: (node: any, options: any) => void) {\n\treturn (elementOrNode = null, options = null) => {\n\t\t// When passed a node, call the hook straight away.\n\t\tif (!isValidElement(elementOrNode)) {\n\t\t\tconst node = elementOrNode\n\t\t\thook(node, options)\n\t\t\t// return the node so it can be chained (e.g. when within callback refs\n\t\t\t// <div ref={node => connectDragSource(connectDropTarget(node))}/>\n\t\t\treturn node\n\t\t}\n\n\t\t// If passed a ReactElement, clone it and attach this function as a ref.\n\t\t// This helps us achieve a neat API where user doesn't even know that refs\n\t\t// are being used under the hood.\n\t\tconst element: ReactElement | null = elementOrNode\n\t\tthrowIfCompositeComponentElement(element as any)\n\n\t\t// When no options are passed, use the hook directly\n\t\tconst ref = options ? (node: Element) => hook(node, options) : hook\n\t\treturn cloneWithRef(element, ref)\n\t}\n}\n\nexport function wrapConnectorHooks(hooks: any) {\n\tconst wrappedHooks: any = {}\n\n\tObject.keys(hooks).forEach((key) => {\n\t\tconst hook = hooks[key]\n\n\t\t// ref objects should be passed straight through without wrapping\n\t\tif (key.endsWith('Ref')) {\n\t\t\twrappedHooks[key] = hooks[key]\n\t\t} else {\n\t\t\tconst wrappedHook = wrapHookToRecognizeElement(hook)\n\t\t\twrappedHooks[key] = () => wrappedHook\n\t\t}\n\t})\n\n\treturn wrappedHooks\n}\n\nfunction setRef(ref: any, node: any) {\n\tif (typeof ref === 'function') {\n\t\tref(node)\n\t} else {\n\t\tref.current = node\n\t}\n}\n\nfunction cloneWithRef(element: any, newRef: any): ReactElement<any> {\n\tconst previousRef = element.ref\n\tinvariant(\n\t\ttypeof previousRef !== 'string',\n\t\t'Cannot connect React DnD to an element with an existing string ref. ' +\n\t\t\t'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' +\n\t\t\t'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs',\n\t)\n\n\tif (!previousRef) {\n\t\t// When there is no ref on the element, use the new ref directly\n\t\treturn cloneElement(element, {\n\t\t\tref: newRef,\n\t\t})\n\t} else {\n\t\treturn cloneElement(element, {\n\t\t\tref: (node: any) => {\n\t\t\t\tsetRef(previousRef, node)\n\t\t\t\tsetRef(newRef, node)\n\t\t\t},\n\t\t})\n\t}\n}\n","import { shallowEqual } from '@react-dnd/shallowequal'\nimport type { Backend, Identifier, Unsubscribe } from 'dnd-core'\nimport type { ReactElement, Ref, RefObject } from 'react'\n\nimport type { DragPreviewOptions, DragSourceOptions } from '../types/index.js'\nimport { isRef } from './isRef.js'\nimport { wrapConnectorHooks } from './wrapConnectorHooks.js'\n\nexport interface Connector {\n\thooks: any\n\tconnectTarget: any\n\treceiveHandlerId(handlerId: Identifier | null): void\n\treconnect(): void\n}\n\nexport class SourceConnector implements Connector {\n\tpublic hooks = wrapConnectorHooks({\n\t\tdragSource: (\n\t\t\tnode: Element | ReactElement | Ref<any>,\n\t\t\toptions?: DragSourceOptions,\n\t\t) => {\n\t\t\tthis.clearDragSource()\n\t\t\tthis.dragSourceOptions = options || null\n\t\t\tif (isRef(node)) {\n\t\t\t\tthis.dragSourceRef = node as RefObject<any>\n\t\t\t} else {\n\t\t\t\tthis.dragSourceNode = node\n\t\t\t}\n\t\t\tthis.reconnectDragSource()\n\t\t},\n\t\tdragPreview: (node: any, options?: DragPreviewOptions) => {\n\t\t\tthis.clearDragPreview()\n\t\t\tthis.dragPreviewOptions = options || null\n\t\t\tif (isRef(node)) {\n\t\t\t\tthis.dragPreviewRef = node\n\t\t\t} else {\n\t\t\t\tthis.dragPreviewNode = node\n\t\t\t}\n\t\t\tthis.reconnectDragPreview()\n\t\t},\n\t})\n\tprivate handlerId: Identifier | null = null\n\n\t// The drop target may either be attached via ref or connect function\n\tprivate dragSourceRef: RefObject<any> | null = null\n\tprivate dragSourceNode: any\n\tprivate dragSourceOptionsInternal: DragSourceOptions | null = null\n\tprivate dragSourceUnsubscribe: Unsubscribe | undefined\n\n\t// The drag preview may either be attached via ref or connect function\n\tprivate dragPreviewRef: RefObject<any> | null = null\n\tprivate dragPreviewNode: any\n\tprivate dragPreviewOptionsInternal: DragPreviewOptions | null = null\n\tprivate dragPreviewUnsubscribe: Unsubscribe | undefined\n\n\tprivate lastConnectedHandlerId: Identifier | null = null\n\tprivate lastConnectedDragSource: any = null\n\tprivate lastConnectedDragSourceOptions: any = null\n\tprivate lastConnectedDragPreview: any = null\n\tprivate lastConnectedDragPreviewOptions: any = null\n\n\tprivate readonly backend: Backend\n\n\tpublic constructor(backend: Backend) {\n\t\tthis.backend = backend\n\t}\n\n\tpublic receiveHandlerId(newHandlerId: Identifier | null): void {\n\t\tif (this.handlerId === newHandlerId) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.handlerId = newHandlerId\n\t\tthis.reconnect()\n\t}\n\n\tpublic get connectTarget(): any {\n\t\treturn this.dragSource\n\t}\n\n\tpublic get dragSourceOptions(): DragSourceOptions | null {\n\t\treturn this.dragSourceOptionsInternal\n\t}\n\tpublic set dragSourceOptions(options: DragSourceOptions | null) {\n\t\tthis.dragSourceOptionsInternal = options\n\t}\n\n\tpublic get dragPreviewOptions(): DragPreviewOptions | null {\n\t\treturn this.dragPreviewOptionsInternal\n\t}\n\n\tpublic set dragPreviewOptions(options: DragPreviewOptions | null) {\n\t\tthis.dragPreviewOptionsInternal = options\n\t}\n\n\tpublic reconnect(): void {\n\t\tconst didChange = this.reconnectDragSource()\n\t\tthis.reconnectDragPreview(didChange)\n\t}\n\n\tprivate reconnectDragSource(): boolean {\n\t\tconst dragSource = this.dragSource\n\t\t// if nothing has changed then don't resubscribe\n\t\tconst didChange =\n\t\t\tthis.didHandlerIdChange() ||\n\t\t\tthis.didConnectedDragSourceChange() ||\n\t\t\tthis.didDragSourceOptionsChange()\n\n\t\tif (didChange) {\n\t\t\tthis.disconnectDragSource()\n\t\t}\n\n\t\tif (!this.handlerId) {\n\t\t\treturn didChange\n\t\t}\n\t\tif (!dragSource) {\n\t\t\tthis.lastConnectedDragSource = dragSource\n\t\t\treturn didChange\n\t\t}\n\n\t\tif (didChange) {\n\t\t\tthis.lastConnectedHandlerId = this.handlerId\n\t\t\tthis.lastConnectedDragSource = dragSource\n\t\t\tthis.lastConnectedDragSourceOptions = this.dragSourceOptions\n\t\t\tthis.dragSourceUnsubscribe = this.backend.connectDragSource(\n\t\t\t\tthis.handlerId,\n\t\t\t\tdragSource,\n\t\t\t\tthis.dragSourceOptions,\n\t\t\t)\n\t\t}\n\t\treturn didChange\n\t}\n\n\tprivate reconnectDragPreview(forceDidChange = false): void {\n\t\tconst dragPreview = this.dragPreview\n\t\t// if nothing has changed then don't resubscribe\n\t\tconst didChange =\n\t\t\tforceDidChange ||\n\t\t\tthis.didHandlerIdChange() ||\n\t\t\tthis.didConnectedDragPreviewChange() ||\n\t\t\tthis.didDragPreviewOptionsChange()\n\n\t\tif (didChange) {\n\t\t\tthis.disconnectDragPreview()\n\t\t}\n\n\t\tif (!this.handlerId) {\n\t\t\treturn\n\t\t}\n\t\tif (!dragPreview) {\n\t\t\tthis.lastConnectedDragPreview = dragPreview\n\t\t\treturn\n\t\t}\n\n\t\tif (didChange) {\n\t\t\tthis.lastConnectedHandlerId = this.handlerId\n\t\t\tthis.lastConnectedDragPreview = dragPreview\n\t\t\tthis.lastConnectedDragPreviewOptions = this.dragPreviewOptions\n\t\t\tthis.dragPreviewUnsubscribe = this.backend.connectDragPreview(\n\t\t\t\tthis.handlerId,\n\t\t\t\tdragPreview,\n\t\t\t\tthis.dragPreviewOptions,\n\t\t\t)\n\t\t}\n\t}\n\n\tprivate didHandlerIdChange(): boolean {\n\t\treturn this.lastConnectedHandlerId !== this.handlerId\n\t}\n\n\tprivate didConnectedDragSourceChange(): boolean {\n\t\treturn this.lastConnectedDragSource !== this.dragSource\n\t}\n\n\tprivate didConnectedDragPreviewChange(): boolean {\n\t\treturn this.lastConnectedDragPreview !== this.dragPreview\n\t}\n\n\tprivate didDragSourceOptionsChange(): boolean {\n\t\treturn !shallowEqual(\n\t\t\tthis.lastConnectedDragSourceOptions,\n\t\t\tthis.dragSourceOptions,\n\t\t)\n\t}\n\n\tprivate didDragPreviewOptionsChange(): boolean {\n\t\treturn !shallowEqual(\n\t\t\tthis.lastConnectedDragPreviewOptions,\n\t\t\tthis.dragPreviewOptions,\n\t\t)\n\t}\n\n\tpublic disconnectDragSource() {\n\t\tif (this.dragSourceUnsubscribe) {\n\t\t\tthis.dragSourceUnsubscribe()\n\t\t\tthis.dragSourceUnsubscribe = undefined\n\t\t}\n\t}\n\n\tpublic disconnectDragPreview() {\n\t\tif (this.dragPreviewUnsubscribe) {\n\t\t\tthis.dragPreviewUnsubscribe()\n\t\t\tthis.dragPreviewUnsubscribe = undefined\n\t\t\tthis.dragPreviewNode = null\n\t\t\tthis.dragPreviewRef = null\n\t\t}\n\t}\n\n\tprivate get dragSource() {\n\t\treturn (\n\t\t\tthis.dragSourceNode || (this.dragSourceRef && this.dragSourceRef.current)\n\t\t)\n\t}\n\n\tprivate get dragPreview() {\n\t\treturn (\n\t\t\tthis.dragPreviewNode ||\n\t\t\t(this.dragPreviewRef && this.dragPreviewRef.current)\n\t\t)\n\t}\n\n\tprivate clearDragSource() {\n\t\tthis.dragSourceNode = null\n\t\tthis.dragSourceRef = null\n\t}\n\n\tprivate clearDragPreview() {\n\t\tthis.dragPreviewNode = null\n\t\tthis.dragPreviewRef = null\n\t}\n}\n","import { invariant } from '@react-dnd/invariant'\nimport type { DragDropManager } from 'dnd-core'\nimport { useContext } from 'react'\n\nimport { DndContext } from '../core/index.js'\n\n/**\n * A hook to retrieve the DragDropManager from Context\n */\nexport function useDragDropManager(): DragDropManager {\n\tconst { dragDropManager } = useContext(DndContext)\n\tinvariant(dragDropManager != null, 'Expected drag drop context')\n\treturn dragDropManager as DragDropManager\n}\n","import { invariant } from '@react-dnd/invariant'\nimport type {\n\tDragDropManager,\n\tDragDropMonitor,\n\tIdentifier,\n\tListener,\n\tUnsubscribe,\n\tXYCoord,\n} from 'dnd-core'\n\nimport type { DragSourceMonitor } from '../types/index.js'\n\nlet isCallingCanDrag = false\nlet isCallingIsDragging = false\n\nexport class DragSourceMonitorImpl implements DragSourceMonitor {\n\tprivate internalMonitor: DragDropMonitor\n\tprivate sourceId: Identifier | null = null\n\n\tpublic constructor(manager: DragDropManager) {\n\t\tthis.internalMonitor = manager.getMonitor()\n\t}\n\n\tpublic receiveHandlerId(sourceId: Identifier | null): void {\n\t\tthis.sourceId = sourceId\n\t}\n\n\tpublic getHandlerId(): Identifier | null {\n\t\treturn this.sourceId\n\t}\n\n\tpublic canDrag(): boolean {\n\t\tinvariant(\n\t\t\t!isCallingCanDrag,\n\t\t\t'You may not call monitor.canDrag() inside your canDrag() implementation. ' +\n\t\t\t\t'Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor',\n\t\t)\n\n\t\ttry {\n\t\t\tisCallingCanDrag = true\n\t\t\treturn this.internalMonitor.canDragSource(this.sourceId as Identifier)\n\t\t} finally {\n\t\t\tisCallingCanDrag = false\n\t\t}\n\t}\n\n\tpublic isDragging(): boolean {\n\t\tif (!this.sourceId) {\n\t\t\treturn false\n\t\t}\n\t\tinvariant(\n\t\t\t!isCallingIsDragging,\n\t\t\t'You may not call monitor.isDragging() inside your isDragging() implementation. ' +\n\t\t\t\t'Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor',\n\t\t)\n\n\t\ttry {\n\t\t\tisCallingIsDragging = true\n\t\t\treturn this.internalMonitor.isDraggingSource(this.sourceId)\n\t\t} finally {\n\t\t\tisCallingIsDragging = false\n\t\t}\n\t}\n\n\tpublic subscribeToStateChange(\n\t\tlistener: Listener,\n\t\toptions?: { handlerIds?: Identifier[] },\n\t): Unsubscribe {\n\t\treturn this.internalMonitor.subscribeToStateChange(listener, options)\n\t}\n\n\tpublic isDraggingSource(sourceId: Identifier): boolean {\n\t\treturn this.internalMonitor.isDraggingSource(sourceId)\n\t}\n\n\tpublic isOverTarget(\n\t\ttargetId: Identifier,\n\t\toptions?: { shallow: boolean },\n\t): boolean {\n\t\treturn this.internalMonitor.isOverTarget(targetId, options)\n\t}\n\n\tpublic getTargetIds(): Identifier[] {\n\t\treturn this.internalMonitor.getTargetIds()\n\t}\n\n\tpublic isSourcePublic(): boolean | null {\n\t\treturn this.internalMonitor.isSourcePublic()\n\t}\n\n\tpublic getSourceId(): Identifier | null {\n\t\treturn this.internalMonitor.getSourceId()\n\t}\n\n\tpublic subscribeToOffsetChange(listener: Listener): Unsubscribe {\n\t\treturn this.internalMonitor.subscribeToOffsetChange(listener)\n\t}\n\n\tpublic canDragSource(sourceId: Identifier): boolean {\n\t\treturn this.internalMonitor.canDragSource(sourceId)\n\t}\n\n\tpublic canDropOnTarget(targetId: Identifier): boolean {\n\t\treturn this.internalMonitor.canDropOnTarget(targetId)\n\t}\n\n\tpublic getItemType(): Identifier | null {\n\t\treturn this.internalMonitor.getItemType()\n\t}\n\n\tpublic getItem(): any {\n\t\treturn this.internalMonitor.getItem()\n\t}\n\n\tpublic getDropResult(): any {\n\t\treturn this.internalMonitor.getDropResult()\n\t}\n\n\tpublic didDrop(): boolean {\n\t\treturn this.internalMonitor.didDrop()\n\t}\n\n\tpublic getInitialClientOffset(): XYCoord | null {\n\t\treturn this.internalMonitor.getInitialClientOffset()\n\t}\n\n\tpublic getInitialSourceClientOffset(): XYCoord | null {\n\t\treturn this.internalMonitor.getInitialSourceClientOffset()\n\t}\n\n\tpublic getSourceClientOffset(): XYCoord | null {\n\t\treturn this.internalMonitor.getSourceClientOffset()\n\t}\n\n\tpublic getClientOffset(): XYCoord | null {\n\t\treturn this.internalMonitor.getClientOffset()\n\t}\n\n\tpublic getDifferenceFromInitialOffset(): XYCoord | null {\n\t\treturn this.internalMonitor.getDifferenceFromInitialOffset()\n\t}\n}\n","import type { DragDropMonitor, DragSource, Identifier } from 'dnd-core'\n\nimport type { Connector } from '../../internals/index.js'\nimport type { DragSourceMonitor } from '../../types/index.js'\nimport type { DragObjectFactory, DragSourceHookSpec } from '../types.js'\n\nexport class DragSourceImpl<O, R, P> implements DragSource {\n\tpublic constructor(\n\t\tpublic spec: DragSourceHookSpec<O, R, P>,\n\t\tprivate monitor: DragSourceMonitor<O, R>,\n\t\tprivate connector: Connector,\n\t) {}\n\n\tpublic beginDrag() {\n\t\tconst spec = this.spec\n\t\tconst monitor = this.monitor\n\n\t\tlet result: O | null = null\n\t\tif (typeof spec.item === 'object') {\n\t\t\tresult = spec.item as O\n\t\t} else if (typeof spec.item === 'function') {\n\t\t\tresult = (spec.item as DragObjectFactory<O>)(monitor)\n\t\t} else {\n\t\t\tresult = {} as O\n\t\t}\n\t\treturn result ?? null\n\t}\n\n\tpublic canDrag() {\n\t\tconst spec = this.spec\n\t\tconst monitor = this.monitor\n\t\tif (typeof spec.canDrag === 'boolean') {\n\t\t\treturn spec.canDrag\n\t\t} else if (typeof spec.canDrag === 'function') {\n\t\t\treturn spec.canDrag(monitor)\n\t\t} else {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tpublic isDragging(globalMonitor: DragDropMonitor, target: Identifier) {\n\t\tconst spec = this.spec\n\t\tconst monitor = this.monitor\n\t\tconst { isDragging } = spec\n\t\treturn isDragging\n\t\t\t? isDragging(monitor)\n\t\t\t: target === globalMonitor.getSourceId()\n\t}\n\n\tpublic endDrag() {\n\t\tconst spec = this.spec\n\t\tconst monitor = this.monitor\n\t\tconst connector = this.connector\n\t\tconst { end } = spec\n\t\tif (end) {\n\t\t\tend(monitor.getItem(), monitor)\n\t\t}\n\t\tconnector.reconnect()\n\t}\n}\n","import type { SourceConnector } from '../../internals/index.js'\nimport { registerSource } from '../../internals/index.js'\nimport type { DragSourceMonitor } from '../../types/index.js'\nimport type { DragSourceHookSpec } from '../types.js'\nimport { useDragDropManager } from '../useDragDropManager.js'\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect.js'\nimport { useDragSource } from './useDragSource.js'\nimport { useDragType } from './useDragType.js'\n\nexport function useRegisteredDragSource<O, R, P>(\n\tspec: DragSourceHookSpec<O, R, P>,\n\tmonitor: DragSourceMonitor<O, R>,\n\tconnector: SourceConnector,\n): void {\n\tconst manager = useDragDropManager()\n\tconst handler = useDragSource(spec, monitor, connector)\n\tconst itemType = useDragType(spec)\n\n\tuseIsomorphicLayoutEffect(\n\t\tfunction registerDragSource() {\n\t\t\tif (itemType != null) {\n\t\t\t\tconst [handlerId, unregister] = registerSource(\n\t\t\t\t\titemType,\n\t\t\t\t\thandler,\n\t\t\t\t\tmanager,\n\t\t\t\t)\n\t\t\t\tmonitor.receiveHandlerId(handlerId)\n\t\t\t\tconnector.receiveHandlerId(handlerId)\n\t\t\t\treturn unregister\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t\t[manager, monitor, connector, handler, itemType],\n\t)\n}\n","import { useEffect, useMemo } from 'react'\n\nimport type { Connector } from '../../internals/index.js'\nimport type { DragSourceMonitor } from '../../types/index.js'\nimport type { DragSourceHookSpec } from '../types.js'\nimport { DragSourceImpl } from './DragSourceImpl.js'\n\nexport function useDragSource<O, R, P>(\n\tspec: DragSourceHookSpec<O, R, P>,\n\tmonitor: DragSourceMonitor<O, R>,\n\tconnector: Connector,\n) {\n\tconst handler = useMemo(\n\t\t() => new DragSourceImpl(spec, monitor, connector),\n\t\t[monitor, connector],\n\t)\n\tuseEffect(() => {\n\t\thandler.spec = spec\n\t}, [spec])\n\treturn handler\n}\n","import { invariant } from '@react-dnd/invariant'\nimport type { Identifier } from 'dnd-core'\nimport { useMemo } from 'react'\n\nimport type { DragSourceHookSpec } from '../types.js'\n\nexport function useDragType(\n\tspec: DragSourceHookSpec<any, any, any>,\n): Identifier {\n\treturn useMemo(() => {\n\t\tconst result: Identifier = spec.type\n\t\tinvariant(result != null, 'spec.type must be defined')\n\t\treturn result\n\t}, [spec])\n}\n","import type {\n\tDragDropManager,\n\tDragSource,\n\tDropTarget,\n\tIdentifier,\n\tSourceType,\n\tTargetType,\n\tUnsubscribe,\n} from 'dnd-core'\n\nexport function registerTarget(\n\ttype: TargetType,\n\ttarget: DropTarget,\n\tmanager: DragDropManager,\n): [Identifier, Unsubscribe] {\n\tconst registry = manager.getRegistry()\n\tconst targetId = registry.addTarget(type, target)\n\n\treturn [targetId, () => registry.removeTarget(targetId)]\n}\n\nexport function registerSource(\n\ttype: SourceType,\n\tsource: DragSource,\n\tmanager: DragDropManager,\n): [Identifier, Unsubscribe] {\n\tconst registry = manager.getRegistry()\n\tconst sourceId = registry.addSource(type, source)\n\n\treturn [sourceId, () => registry.removeSource(sourceId)]\n}\n","import { invariant } from '@react-dnd/invariant'\n\nimport type {\n\tConnectDragPreview,\n\tConnectDragSource,\n} from '../../types/index.js'\nimport type { DragSourceHookSpec, FactoryOrInstance } from '../types.js'\nimport { useCollectedProps } from '../useCollectedProps.js'\nimport { useOptionalFactory } from '../useOptionalFactory.js'\nimport { useConnectDragPreview, useConnectDragSource } from './connectors.js'\nimport { useDragSourceConnector } from './useDragSourceConnector.js'\nimport { useDragSourceMonitor } from './useDragSourceMonitor.js'\nimport { useRegisteredDragSource } from './useRegisteredDragSource.js'\n\n/**\n * useDragSource hook\n * @param sourceSpec The drag source specification (object or function, function preferred)\n * @param deps The memoization deps array to use when evaluating spec changes\n */\nexport function useDrag<\n\tDragObject = unknown,\n\tDropResult = unknown,\n\tCollectedProps = unknown,\n>(\n\tspecArg: FactoryOrInstance<\n\t\tDragSourceHookSpec<DragObject, DropResult, CollectedProps>\n\t>,\n\tdeps?: unknown[],\n): [CollectedProps, ConnectDragSource, ConnectDragPreview] {\n\tconst spec = useOptionalFactory(specArg, deps)\n\tinvariant(\n\t\t!(spec as any).begin,\n\t\t`useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`,\n\t)\n\n\tconst monitor = useDragSourceMonitor<DragObject, DropResult>()\n\tconst connector = useDragSourceConnector(spec.options, spec.previewOptions)\n\tuseRegisteredDragSource(spec, monitor, connector)\n\n\treturn [\n\t\tuseCollectedProps(spec.collect, monitor, connector),\n\t\tuseConnectDragSource(connector),\n\t\tuseConnectDragPreview(connector),\n\t]\n}\n","import { useMemo } from 'react'\n\nimport { DragSourceMonitorImpl } from '../../internals/index.js'\nimport type { DragSourceMonitor } from '../../types/index.js'\nimport { useDragDropManager } from '../useDragDropManager.js'\n\nexport function useDragSourceMonitor<O, R>(): DragSourceMonitor<O, R> {\n\tconst manager = useDragDropManager()\n\treturn useMemo<DragSourceMonitor<O, R>>(\n\t\t() => new DragSourceMonitorImpl(manager),\n\t\t[manager],\n\t)\n}\n","import { useMemo } from 'react'\n\nimport { SourceConnector } from '../../internals/index.js'\nimport type {\n\tDragPreviewOptions,\n\tDragSourceOptions,\n} from '../../types/index.js'\nimport { useDragDropManager } from '../useDragDropManager.js'\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect.js'\n\nexport function useDragSourceConnector(\n\tdragSourceOptions: DragSourceOptions | undefined,\n\tdragPreviewOptions: DragPreviewOptions | undefined,\n): SourceConnector {\n\tconst manager = useDragDropManager()\n\tconst connector = useMemo(\n\t\t() => new SourceConnector(manager.getBackend()),\n\t\t[manager],\n\t)\n\tuseIsomorphicLayoutEffect(() => {\n\t\tconnector.dragSourceOptions = dragSourceOptions || null\n\t\tconnector.reconnect()\n\t\treturn () => connector.disconnectDragSource()\n\t}, [connector, dragSourceOptions])\n\tuseIsomorphicLayoutEffect(() => {\n\t\tconnector.dragPreviewOptions = dragPreviewOptions || null\n\t\tconnector.reconnect()\n\t\treturn () => connector.disconnectDragPreview()\n\t}, [connector, dragPreviewOptions])\n\treturn connector\n}\n","import { useEffect } from 'react'\n\nimport type { DragLayerMonitor } from '../types/index.js'\nimport { useCollector } from './useCollector.js'\nimport { useDragDropManager } from './useDragDropManager.js'\n\n/**\n * useDragLayer Hook\n * @param collector The property collector\n */\nexport function useDragLayer<CollectedProps, DragObject = any>(\n\tcollect: (monitor: DragLayerMonitor<DragObject>) => CollectedProps,\n): CollectedProps {\n\tconst dragDropManager = useDragDropManager()\n\tconst monitor = dragDropManager.getMonitor()\n\tconst [collected, updateCollected] = useCollector(monitor, collect)\n\n\tuseEffect(() => monitor.subscribeToOffsetChange(updateCollected))\n\tuseEffect(() => monitor.subscribeToStateChange(updateCollected))\n\treturn collected\n}\n","import { useMemo } from 'react'\n\nimport type { TargetConnector } from '../../internals/index.js'\n\nexport function useConnectDropTarget(connector: TargetConnector) {\n\treturn useMemo(() => connector.hooks.dropTarget(), [connector])\n}\n","import { shallowEqual } from '@react-dnd/shallowequal'\nimport type { Backend, Identifier, Unsubscribe } from 'dnd-core'\nimport type { RefObject } from 'react'\n\nimport type { DropTargetOptions } from '../types/index.js'\nimport { isRef } from './isRef.js'\nimport type { Connector } from './SourceConnector.js'\nimport { wrapConnectorHooks } from './wrapConnectorHooks.js'\n\nexport class TargetConnector implements Connector {\n\tpublic hooks = wrapConnectorHooks({\n\t\tdropTarget: (node: any, options: DropTargetOptions) => {\n\t\t\tthis.clearDropTarget()\n\t\t\tthis.dropTargetOptions = options\n\t\t\tif (isRef(node)) {\n\t\t\t\tthis.dropTargetRef = node\n\t\t\t} else {\n\t\t\t\tthis.dropTargetNode = node\n\t\t\t}\n\t\t\tthis.reconnect()\n\t\t},\n\t})\n\n\tprivate handlerId: Identifier | null = null\n\t// The drop target may either be attached via ref or connect function\n\tprivate dropTargetRef: RefObject<any> | null = null\n\tprivate dropTargetNode: any\n\tprivate dropTargetOptionsInternal: DropTargetOptions | null = null\n\tprivate unsubscribeDropTarget: Unsubscribe | undefined\n\n\tprivate lastConnectedHandlerId: Identifier | null = null\n\tprivate lastConnectedDropTarget: any = null\n\tprivate lastConnectedDropTargetOptions: DropTargetOptions | null = null\n\tprivate readonly backend: Backend\n\n\tpublic constructor(backend: Backend) {\n\t\tthis.backend = backend\n\t}\n\n\tpublic get connectTarget(): any {\n\t\treturn this.dropTarget\n\t}\n\n\tpublic reconnect(): void {\n\t\t// if nothing has changed then don't resubscribe\n\t\tconst didChange =\n\t\t\tthis.didHandlerIdChange() ||\n\t\t\tthis.didDropTargetChange() ||\n\t\t\tthis.didOptionsChange()\n\n\t\tif (didChange) {\n\t\t\tthis.disconnectDropTarget()\n\t\t}\n\n\t\tconst dropTarget = this.dropTarget\n\t\tif (!this.handlerId) {\n\t\t\treturn\n\t\t}\n\t\tif (!dropTarget) {\n\t\t\tthis.lastConnectedDropTarget = dropTarget\n\t\t\treturn\n\t\t}\n\n\t\tif (didChange) {\n\t\t\tthis.lastConnectedHandlerId = this.handlerId\n\t\t\tthis.lastConnectedDropTarget = dropTarget\n\t\t\tthis.lastConnectedDropTargetOptions = this.dropTargetOptions\n\n\t\t\tthis.unsubscribeDropTarget = this.backend.connectDropTarget(\n\t\t\t\tthis.handlerId,\n\t\t\t\tdropTarget,\n\t\t\t\tthis.dropTargetOptions,\n\t\t\t)\n\t\t}\n\t}\n\n\tpublic receiveHandlerId(newHandlerId: Identifier | null): void {\n\t\tif (newHandlerId === this.handlerId) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.handlerId = newHandlerId\n\t\tthis.reconnect()\n\t}\n\n\tpublic get dropTargetOptions(): DropTargetOptions {\n\t\treturn this.dropTargetOptionsInternal\n\t}\n\tpublic set dropTargetOptions(options: DropTargetOptions) {\n\t\tthis.dropTargetOptionsInternal = options\n\t}\n\n\tprivate didHandlerIdChange(): boolean {\n\t\treturn this.lastConnectedHandlerId !== this.handlerId\n\t}\n\n\tprivate didDropTargetChange(): boolean {\n\t\treturn this.lastConnectedDropTarget !== this.dropTarget\n\t}\n\n\tprivate didOptionsChange(): boolean {\n\t\treturn !shallowEqual(\n\t\t\tthis.lastConnectedDropTargetOptions,\n\t\t\tthis.dropTargetOptions,\n\t\t)\n\t}\n\n\tpublic disconnectDropTarget() {\n\t\tif (this.unsubscribeDropTarget) {\n\t\t\tthis.unsubscribeDropTarget()\n\t\t\tthis.unsubscribeDropTarget = undefined\n\t\t}\n\t}\n\n\tprivate get dropTarget() {\n\t\treturn (\n\t\t\tthis.dropTargetNode || (this.dropTargetRef && this.dropTargetRef.current)\n\t\t)\n\t}\n\n\tprivate clearDropTarget() {\n\t\tthis.dropTargetRef = null\n\t\tthis.dropTargetNode = null\n\t}\n}\n","import { invariant } from '@react-dnd/invariant'\nimport type {\n\tDragDropManager,\n\tDragDropMonitor,\n\tIdentifier,\n\tListener,\n\tUnsubscribe,\n\tXYCoord,\n} from 'dnd-core'\n\nimport type { DropTargetMonitor } from '../types/index.js'\n\nlet isCallingCanDrop = false\n\nexport class DropTargetMonitorImpl implements DropTargetMonitor {\n\tprivate internalMonitor: DragDropMonitor\n\tprivate targetId: Identifier | null = null\n\n\tpublic constructor(manager: DragDropManager) {\n\t\tthis.internalMonitor = manager.getMonitor()\n\t}\n\n\tpublic receiveHandlerId(targetId: Identifier | null): void {\n\t\tthis.targetId = targetId\n\t}\n\n\tpublic getHandlerId(): Identifier | null {\n\t\treturn this.targetId\n\t}\n\n\tpublic subscribeToStateChange(\n\t\tlistener: Listener,\n\t\toptions?: { handlerIds?: Identifier[] },\n\t): Unsubscribe {\n\t\treturn this.internalMonitor.subscribeToStateChange(listener, options)\n\t}\n\n\tpublic canDrop(): boolean {\n\t\t// Cut out early if the target id has not been set. This should prevent errors\n\t\t// where the user has an older version of dnd-core like in\n\t\t// https://github.com/react-dnd/react-dnd/issues/1310\n\t\tif (!this.targetId) {\n\t\t\treturn false\n\t\t}\n\t\tinvariant(\n\t\t\t!isCallingCanDrop,\n\t\t\t'You may not call monitor.canDrop() inside your canDrop() implementation. ' +\n\t\t\t\t'Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor',\n\t\t)\n\n\t\ttry {\n\t\t\tisCallingCanDrop = true\n\t\t\treturn this.internalMonitor.canDropOnTarget(this.targetId)\n\t\t} finally {\n\t\t\tisCallingCanDrop = false\n\t\t}\n\t}\n\n\tpublic isOver(options?: { shallow?: boolean }): boolean {\n\t\tif (!this.targetId) {\n\t\t\treturn false\n\t\t}\n\t\treturn this.internalMonitor.isOverTarget(this.targetId, options)\n\t}\n\n\tpublic getItemType(): Identifier | null {\n\t\treturn this.internalMonitor.getItemType()\n\t}\n\n\tpublic getItem(): any {\n\t\treturn this.internalMonitor.getItem()\n\t}\n\n\tpublic getDropResult(): any {\n\t\treturn this.internalMonitor.getDropResult()\n\t}\n\n\tpublic didDrop(): boolean {\n\t\treturn this.internalMonitor.didDrop()\n\t}\n\n\tpublic getInitialClientOffset(): XYCoord | null {\n\t\treturn this.internalMonitor.getInitialClientOffset()\n\t}\n\n\tpublic getInitialSourceClientOffset(): XYCoord | null {\n\t\treturn this.internalMonitor.getInitialSourceClientOffset()\n\t}\n\n\tpublic getSourceClientOffset(): XYCoord | null {\n\t\treturn this.internalMonitor.getSourceClientOffset()\n\t}\n\n\tpublic getClientOffset(): XYCoord | null {\n\t\treturn this.internalMonitor.getClientOffset()\n\t}\n\n\tpublic getDifferenceFromInitialOffset(): XYCoord | null {\n\t\treturn this.internalMonitor.getDifferenceFromInitialOffset()\n\t}\n}\n","import type { DropTarget } from 'dnd-core'\n\nimport type { DropTargetMonitor } from '../../types/index.js'\nimport type { DropTargetHookSpec } from '../types.js'\n\nexport class DropTargetImpl<O, R, P> implements DropTarget {\n\tpublic constructor(\n\t\tpublic spec: DropTargetHookSpec<O, R, P>,\n\t\tprivate monitor: DropTargetMonitor<O, R>,\n\t) {}\n\n\tpublic canDrop() {\n\t\tconst spec = this.spec\n\t\tconst monitor = this.monitor\n\t\treturn spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true\n\t}\n\n\tpublic hover() {\n\t\tconst spec = this.spec\n\t\tconst monitor = this.monitor\n\t\tif (spec.hover) {\n\t\t\tspec.hover(monitor.getItem(), monitor)\n\t\t}\n\t}\n\n\tpublic drop() {\n\t\tconst spec = this.spec\n\t\tconst monitor = this.monitor\n\t\tif (spec.drop) {\n\t\t\treturn spec.drop(monitor.getItem(), monitor)\n\t\t}\n\t\treturn\n\t}\n}\n","import type { TargetConnector } from '../../internals/index.js'\nimport { registerTarget } from '../../internals/index.js'\nimport type { DropTargetMonitor } from '../../types/index.js'\nimport type { DropTargetHookSpec } from '../types.js'\nimport { useDragDropManager } from '../useDragDropManager.js'\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect.js'\nimport { useAccept } from './useAccept.js'\nimport { useDropTarget } from './useDropTarget.js'\n\nexport function useRegisteredDropTarget<O, R, P>(\n\tspec: DropTargetHookSpec<O, R, P>,\n\tmonitor: DropTargetMonitor<O, R>,\n\tconnector: TargetConnector,\n): void {\n\tconst manager = useDragDropManager()\n\tconst dropTarget = useDropTarget(spec, monitor)\n\tconst accept = useAccept(spec)\n\n\tuseIsomorphicLayoutEffect(\n\t\tfunction registerDropTarget() {\n\t\t\tconst [handlerId, unregister] = registerTarget(\n\t\t\t\taccept,\n\t\t\t\tdropTarget,\n\t\t\t\tmanager,\n\t\t\t)\n\t\t\tmonitor.receiveHandlerId(handlerId)\n\t\t\tconnector.receiveHandlerId(handlerId)\n\t\t\treturn unregister\n\t\t},\n\t\t[\n\t\t\tmanager,\n\t\t\tmonitor,\n\t\t\tdropTarget,\n\t\t\tconnector,\n\t\t\taccept.map((a) => a.toString()).join('|'),\n\t\t],\n\t)\n}\n","import { useEffect, useMemo } from 'react'\n\nimport type { DropTargetMonitor } from '../../types/index.js'\nimport type { DropTargetHookSpec } from '../types.js'\nimport { DropTargetImpl } from './DropTargetImpl.js'\n\nexport function useDropTarget<O, R, P>(\n\tspec: DropTargetHookSpec<O, R, P>,\n\tmonitor: DropTargetMonitor<O, R>,\n) {\n\tconst dropTarget = useMemo(() => new DropTargetImpl(spec, monitor), [monitor])\n\tuseEffect(() => {\n\t\tdropTarget.spec = spec\n\t}, [spec])\n\treturn dropTarget\n}\n","import { invariant } from '@react-dnd/invariant'\nimport type { Identifier } from 'dnd-core'\nimport { useMemo } from 'react'\n\nimport type { DropTargetHookSpec } from '../types.js'\n\n/**\n * Internal utility hook to get an array-version of spec.accept.\n * The main utility here is that we aren't creating a new array on every render if a non-array spec.accept is passed in.\n * @param spec\n */\nexport function useAccept<O, R, P>(\n\tspec: DropTargetHookSpec<O, R, P>,\n): Identifier[] {\n\tconst { accept } = spec\n\treturn useMemo(() => {\n\t\tinvariant(spec.accept != null, 'accept must be defined')\n\t\treturn Array.isArray(accept) ? accept : [accept]\n\t}, [accept])\n}\n","import type { ConnectDropTarget } from '../../types/index.js'\nimport type { DropTargetHookSpec, FactoryOrInstance } from '../types.js'\nimport { useCollectedProps } from '../useCollectedProps.js'\nimport { useOptionalFactory } from '../useOptionalFactory.js'\nimport { useConnectDropTarget } from './connectors.js'\nimport { useDropTargetConnector } from './useDropTargetConnector.js'\nimport { useDropTargetMonitor } from './useDropTargetMonitor.js'\nimport { useRegisteredDropTarget } from './useRegisteredDropTarget.js'\n\n/**\n * useDropTarget Hook\n * @param spec The drop target specification (object or function, function preferred)\n * @param deps The memoization deps array to use when evaluating spec changes\n */\nexport function useDrop<\n\tDragObject = unknown,\n\tDropResult = unknown,\n\tCollectedProps = unknown,\n>(\n\tspecArg: FactoryOrInstance<\n\t\tDropTargetHookSpec<DragObject, DropResult, CollectedProps>\n\t>,\n\tdeps?: unknown[],\n): [CollectedProps, ConnectDropTarget] {\n\tconst spec = useOptionalFactory(specArg, deps)\n\tconst monitor = useDropTargetMonitor<DragObject, DropResult>()\n\tconst connector = useDropTargetConnector(spec.options)\n\tuseRegisteredDropTarget(spec, monitor, connector)\n\n\treturn [\n\t\tuseCollectedProps(spec.collect, monitor, connector),\n\t\tuseConnectDropTarget(connector),\n\t]\n}\n","import { useMemo } from 'react'\n\nimport { DropTargetMonitorImpl } from '../../internals/index.js'\nimport type { DropTargetMonitor } from '../../types/index.js'\nimport { useDragDropManager } from '../useDragDropManager.js'\n\nexport function useDropTargetMonitor<O, R>(): DropTargetMonitor<O, R> {\n\tconst manager = useDragDropManager()\n\treturn useMemo(() => new DropTargetMonitorImpl(manager), [manager])\n}\n","import { useMemo } from 'react'\n\nimport { TargetConnector } from '../../internals/index.js'\nimport type { DropTargetOptions } from '../../types/index.js'\nimport { useDragDropManager } from '../useDragDropManager.js'\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect.js'\n\nexport function useDropTargetConnector(\n\toptions: DropTargetOptions,\n): TargetConnector {\n\tconst manager = useDragDropManager()\n\tconst connector = useMemo(\n\t\t() => new TargetConnector(manager.getBackend()),\n\t\t[manager],\n\t)\n\tuseIsomorphicLayoutEffect(() => {\n\t\tconnector.dropTargetOptions = options || null\n\t\tconnector.reconnect()\n\t\treturn () => connector.disconnectDropTarget()\n\t}, [options])\n\treturn connector\n}\n"],"names":["module","exports","equal","a","b","constructor","length","i","keys","Array","isArray","RegExp","source","flags","valueOf","Object","prototype","toString","hasOwnProperty","call","key","DndContext","createContext","dragDropManager","undefined","invariant","condition","format","args","isProduction","Error","error","argIndex","replace","name","framesToPop","process","get","obj","path","defaultValue","split","reduce","c","without","items","item","filter","isObject","input","xor","itemsA","itemsB","map","Map","insertItem","set","has","forEach","result","count","push","INIT_COORDS","BEGIN_DRAG","PUBLISH_DRAG_SOURCE","HOVER","DROP","END_DRAG","setClientOffset","clientOffset","sourceClientOffset","type","payload","ResetCoordinatesAction","createBeginDrag","manager","sourceIds","options","publishSource","getSourceClientOffset","monitor","getMonitor","registry","getRegistry","dispatch","verifyInvariants","sourceId","getDraggableSource","verifyGetSourceClientOffsetIsFunction","getSource","beginDrag","verifyItemIsObject","pinSource","itemType","getSourceType","isSourcePublic","isDragging","canDragSource","createDrop","targetIds","getDroppableTargets","targetId","index","dropResult","determineDropResult","action","_objectSpread","didDrop","target","getTarget","drop","verifyDropResultType","getDropResult","getTargetIds","canDropOnTarget","reverse","createEndDrag","verifyIsDragging","getSourceId","endDrag","unpinSource","matchesType","targetType","draggedItemType","some","t","createHover","targetIdsArg","verifyTargetIdsIsArray","slice","getItemType","removeNonMatchingTargetIds","checkInvariants","hoverAllTargets","lastIndexOf","getTargetType","splice","hover","createPublishDragSource","DragDropManagerImpl","store","isSetUp","handleRefCountChange","shouldSetUp","getState","refCount","backend","setup","teardown","this","subscribe","actions","publishDragSource","createDragDropActions","boundActions","actionCreator","apply","subtract","x","y","NONE","ALL","areDirty","dirtyIds","handlerIds","indexOf","__IS_NONE__","__IS_ALL__","DragDropMonitorImpl","listener","prevStateId","stateId","handleChange","state","currentStateId","dirtyHandlerIds","previousState","dragOffset","nextState","canDrag","canDrop","Boolean","shallow","dragOperation","initialClientOffset","initialSourceClientOffset","getDifferenceFromInitialOffset","scope","global","self","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","makeRequestCallFromTimer","callback","timeoutHandle","setTimeout","handleTimer","intervalHandle","setInterval","clearTimeout","clearInterval","makeRequestCall","toggle","observer","node","document","createTextNode","observe","characterData","data","AsapQueue","queue","pendingErrors","flushing","capacity","flush","q","currentIndex","scan","newLength","registerPendingError","err","requestErrorThrow","requestFlush","shift","task","RawTask","onError","release","TaskFactory","freeTasks","tasks","pop","asapQueue","taskFactory","HandlerRole","ADD_SOURCE","ADD_TARGET","REMOVE_SOURCE","REMOVE_TARGET","validateType","allowArray","SOURCE","TARGET","nextUniqueId","getNextHandlerId","role","id","parseRoleFromHandlerId","handlerId","mapContainsValue","searchValue","entries","isDone","next","done","value","HandlerRegistryImpl","types","dragSources","dropTargets","pinnedSourceId","pinnedSource","validateSourceContract","addHandler","addSource","validateTargetContract","addTarget","handler","includePinned","isSourceId","isPinned","isTargetId","removeSource","delete","enqueueTask","create","removeTarget","strictEquality","areCoordsEqual","offsetA","offsetB","areArraysEqual","isEqual","prevTargetIds","didChange","prevInnermostTargetId","innermostTargetId","initialState","createDragDropManager","backendFactory","globalContext","backendOptions","debugMode","makeStoreInstance","receiveBackend","reduxDevTools","window","__REDUX_DEVTOOLS_EXTENSION__","createStore","instanceId","INSTANCE_SYM","Symbol","for","DndProvider","memo","_param","children","props","context","getGlobalContext","ctx","createSingletonDndContext","isGlobalInstance","getDndContextValue","_objectWithoutProperties","useEffect","_jsx","Provider","DragPreviewImage","connect","src","Image","connected","img","onload","useIsomorphicLayoutEffect","useLayoutEffect","useCollector","collect","onUpdate","useState","collected","setCollected","updateCollected","useCallback","nextValue","useCollectedProps","collector","connector","onCollect","getHandlerId","subscribeToStateChange","useMonitorOutput","reconnect","useOptionalFactory","arg","deps","memoDeps","useMemo","useConnectDragSource","hooks","dragSource","useConnectDragPreview","dragPreview","shallowEqual","objA","objB","compare","compareContext","compareResult","keysA","keysB","bHasOwnProperty","bind","idx","valueA","valueB","isRef","throwIfCompositeComponentElement","element","displayName","wrapConnectorHooks","wrappedHooks","hook","endsWith","wrappedHook","elementOrNode","isValidElement","ref","cloneWithRef","wrapHookToRecognizeElement","setRef","current","newRef","previousRef","cloneElement","SourceConnector","clearDragSource","dragSourceOptions","dragSourceRef","dragSourceNode","reconnectDragSource","clearDragPreview","dragPreviewOptions","dragPreviewRef","dragPreviewNode","reconnectDragPreview","dragSourceOptionsInternal","dragPreviewOptionsInternal","lastConnectedHandlerId","lastConnectedDragSource","lastConnectedDragSourceOptions","lastConnectedDragPreview","lastConnectedDragPreviewOptions","newHandlerId","didHandlerIdChange","didConnectedDragSourceChange","didDragSourceOptionsChange","disconnectDragSource","dragSourceUnsubscribe","connectDragSource","forceDidChange","didConnectedDragPreviewChange","didDragPreviewOptionsChange","disconnectDragPreview","dragPreviewUnsubscribe","connectDragPreview","useDragDropManager","useContext","isCallingCanDrag","isCallingIsDragging","DragSourceMonitorImpl","internalMonitor","isDraggingSource","isOverTarget","subscribeToOffsetChange","getItem","getInitialClientOffset","getInitialSourceClientOffset","getClientOffset","DragSourceImpl","spec","globalMonitor","end","useRegisteredDragSource","useDragSource","useDragType","registerSource","unregister","receiveHandlerId","useDrag","specArg","begin","useDragSourceMonitor","getBackend","useDragSourceConnector","previewOptions","useDragLayer","useConnectDropTarget","dropTarget","TargetConnector","clearDropTarget","dropTargetOptions","dropTargetRef","dropTargetNode","dropTargetOptionsInternal","lastConnectedDropTarget","lastConnectedDropTargetOptions","didDropTargetChange","didOptionsChange","disconnectDropTarget","unsubscribeDropTarget","connectDropTarget","isCallingCanDrop","DropTargetMonitorImpl","DropTargetImpl","useRegisteredDropTarget","useDropTarget","accept","useAccept","registerTarget","join","useDrop","useDropTargetMonitor","useDropTargetConnector"],"sourceRoot":""}